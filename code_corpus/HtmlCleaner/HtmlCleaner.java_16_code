    private void closeAll(final List<BaseToken> nodeList, final CleanTimeValues cleanTimeValues) {
        final TagPos firstTagPos = cleanTimeValues.openTags.findFirstTagPos();
        if (firstTagPos != null) {
            closeSnippet(nodeList, firstTagPos, null, cleanTimeValues);
        }
    }

    private List closeSnippet(final List nodeList, final TagPos tagPos, final Object toNode,
            final CleanTimeValues cleanTimeValues) {
        final List closed = new ArrayList();
        final ListIterator it = nodeList.listIterator(tagPos.position);

        TagNode tagNode = null;
        Object item = it.next();
        boolean isListEnd = false;

        while ((toNode == null && !isListEnd) || (toNode != null && item != toNode)) {
            if (isStartToken(item)) {
                final TagNode startTagToken = (TagNode) item;
                closed.add(startTagToken);
                final List<BaseToken> itemsToMove = startTagToken.getItemsToMove();
                if (itemsToMove != null) {
                    final OpenTags prevOpenTags = cleanTimeValues.openTags;
                    cleanTimeValues.openTags = new OpenTags();
                    makeTree(itemsToMove, itemsToMove.listIterator(0), cleanTimeValues);
                    closeAll(itemsToMove, cleanTimeValues);
                    startTagToken.setItemsToMove(null);
                    cleanTimeValues.openTags = prevOpenTags;
                }

                final TagNode newTagNode = createTagNode(startTagToken);
                final TagInfo tag = tagInfoProvider.getTagInfo(newTagNode.getName());
                addPossibleHeadCandidate(tag, newTagNode, cleanTimeValues);
                if (tagNode != null) {
                    tagNode.addChildren(itemsToMove);
                    tagNode.addChild(newTagNode);
                    it.set(null);
                } else {
                    if (itemsToMove != null) {
                        itemsToMove.add(newTagNode);
                        it.set(itemsToMove);
                    } else {
                        it.set(newTagNode);
                    }
                }

                cleanTimeValues.openTags.removeTag(newTagNode.getName());
                tagNode = newTagNode;
            } else {
                if (tagNode != null) {
                    it.set(null);
                    if (item != null) {
                        tagNode.addChild(item);
                    }
                }
            }

            if (it.hasNext()) {
                item = it.next();
            } else {
                isListEnd = true;
            }
        }

        return closed;
    }

    private void createDocumentNodes(final List listNodes, final CleanTimeValues cleanTimeValues) {
        final Iterator it = listNodes.iterator();
        while (it.hasNext()) {
            final Object child = it.next();

            if (child == null) {
                continue;
            }

            boolean toAdd = true;

            if (child instanceof TagNode) {
                final TagNode node = (TagNode) child;
                final TagInfo tag = tagInfoProvider.getTagInfo(node.getName());
                addPossibleHeadCandidate(tag, node, cleanTimeValues);
            } else {
                if (child instanceof ContentNode) {
                    toAdd = !"".equals(child.toString());
                }
            }

            if (toAdd) {
                cleanTimeValues.bodyNode.addChild(child);
            }
        }

        // move all viable head candidates to head section of the tree
        final Iterator headIterator = cleanTimeValues.headTags.iterator();
        while (headIterator.hasNext()) {
            final TagNode headCandidateNode = (TagNode) headIterator.next();

            // check if this node is already inside a candidate for moving to
            // head
            TagNode parent = headCandidateNode.getParent();
            boolean toMove = true;
            while (parent != null) {
                if (cleanTimeValues.headTags.contains(parent)) {
                    toMove = false;
                    break;
                }
                parent = parent.getParent();
            }

            if (toMove) {
                headCandidateNode.removeFromTree();
                cleanTimeValues.headNode.addChild(headCandidateNode);
            }
        }
    }

    private TagNode createTagNode(final String name, final CleanTimeValues cleanTimeValues) {
        final TagNode node = new TagNode(name);
        if (cleanTimeValues.pruneTagSet != null && name != null
                && cleanTimeValues.pruneTagSet.contains(name.toLowerCase())) {
            cleanTimeValues.pruneNodeSet.add(node);
        }
        return node;
    }

    private TagNode createTagNode(final TagNode startTagToken) {
        startTagToken.setFormed();
        return startTagToken;
    }

