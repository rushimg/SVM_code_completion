    public static String escapeXml(final String s, final CleanerProperties props, final boolean isDomCreation) {
        final boolean advanced = props.isAdvancedXmlEscape();
        final boolean recognizeUnicodeChars = props.isRecognizeUnicodeChars();
        final boolean translateSpecialEntities = props.isTranslateSpecialEntities();

        if (s != null) {
            final int len = s.length();
            final StringBuilder result = new StringBuilder(len);

            for (int i = 0; i < len; i++) {
                final char ch = s.charAt(i);

                if (ch == '&') {
                    if ((advanced || recognizeUnicodeChars) && (i < len - 2) && (s.charAt(i + 1) == '#')) {
                        final boolean isHex = Character.toLowerCase(s.charAt(i + 2)) == 'x';
                        int charIndex = i + (isHex ? 3 : 2);
                        final int radix = isHex ? 16 : 10;
                        String unicode = "";
                        while (charIndex < len) {
                            final char currCh = s.charAt(charIndex);
                            if (currCh == ';') {
                                break;
                            } else if (isValidInt(unicode + currCh, radix)) {
                                unicode += currCh;
                                charIndex++;
                            } else {
                                charIndex--;
                                break;
                            }
                        }

                        if (isValidInt(unicode, radix)) {
                            final char unicodeChar = (char) Integer.parseInt(unicode, radix);
                            if (!isValidXmlChar(unicodeChar)) {
                                i = charIndex;
                            } else if (!isReservedXmlChar(unicodeChar)) {
                                result.append(recognizeUnicodeChars ? String.valueOf(unicodeChar) : "&#" + unicode
                                        + ";");
                                i = charIndex;
                            } else {
                                i = charIndex;
                                result.append("&#" + (isHex ? "x" : "") + unicode + ";");
                            }
                        } else {
                            result.append("&amp;");
                        }
                    } else {
                        if (translateSpecialEntities) {
                            // get minimal following sequence required to
                            // recognize some special entitiy
                            final String seq = s.substring(i,
                                    i + Math.min(SpecialEntity.getMaxEntityLength() + 2, len - i));
                            final int semiIndex = seq.indexOf(';');
                            if (semiIndex > 0) {
                                final String entityKey = seq.substring(1, semiIndex);
                                final SpecialEntity entity = SpecialEntity.getEntity(entityKey);
                                if (entity != null) {
                                    result.append(props.isTransSpecialEntitiesToNCR() ? entity.getDecimalNCR() : entity
                                            .getCharacter());
                                    i += entityKey.length() + 1;
                                    continue;
                                }
                            }
                        }

                        if (advanced) {
                            final String sub = s.substring(i);
                            boolean isReservedSeq = false;
                            for (int j = 0; j < RESERVED_XML_CHARS_LIST.length; j++) {
                                final char currentChar = RESERVED_XML_CHARS_LIST[j];
                                final String seq = RESERVED_XML_CHARS[currentChar];
                                if (sub.startsWith(seq)) {
                                    result.append(isDomCreation ? currentChar : (props.isTransResCharsToNCR() ? "&#"
                                            + (int) currentChar + ";" : seq));
                                    i += seq.length() - 1;
                                    isReservedSeq = true;
                                    break;
                                }
                            }
                            if (!isReservedSeq) {
                                result.append(isDomCreation ? "&" : (props.isTransResCharsToNCR() ? "&#" + (int) '&'
                                        + ";" : RESERVED_XML_CHARS['&']));
                            }
                            continue;
                        }

                        result.append("&amp;");
                    }
                } else if (isReservedXmlChar(ch)) {
                    result.append(props.isTransResCharsToNCR() ? "&#" + (int) ch + ";" : (isDomCreation ? ch
                            : RESERVED_XML_CHARS[ch]));
                } else {
                    result.append(ch);
                }
            }

            return result.toString();
        }

        return null;
    }

