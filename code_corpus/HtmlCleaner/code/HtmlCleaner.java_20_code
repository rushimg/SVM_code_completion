    private boolean isFatalTagSatisfied(final TagInfo tag, final CleanTimeValues cleanTimeValues) {
        if (tag != null) {
            final String fatalTagName = tag.getFatalTag();
            return fatalTagName == null ? true : cleanTimeValues.openTags.tagExists(fatalTagName);
        }

        return true;
    }

    private boolean isStartToken(final Object o) {
        return (o instanceof TagNode) && !((TagNode) o).isFormed();
    }

    private TagNode makeTagNodeCopy(final TagNode tagNode, final CleanTimeValues cleanTimeValues) {
        final TagNode copy = tagNode.makeCopy();
        if (cleanTimeValues.pruneTagSet != null && cleanTimeValues.pruneTagSet.contains(tagNode.getName())) {
            cleanTimeValues.pruneNodeSet.add(copy);
        }
        return copy;
    }

    public void makeTree(final List<BaseToken> nodeList, final ListIterator<BaseToken> nodeIterator,
            final CleanTimeValues cleanTimeValues) {
        // process while not reach the end of the list
        while (nodeIterator.hasNext()) {
            final BaseToken token = nodeIterator.next();

            if (token instanceof EndTagToken) {
                final EndTagToken endTagToken = (EndTagToken) token;
                final String tagName = endTagToken.getName();
                final TagInfo tag = tagInfoProvider.getTagInfo(tagName);

                if ((tag == null && properties.isOmitUnknownTags())
                        || (tag != null && tag.isDeprecated() && properties.isOmitDeprecatedTags())) {
                    nodeIterator.set(null);
                } else if (tag != null && !tag.allowsBody()) {
                    nodeIterator.set(null);
                } else {
                    final TagPos matchingPosition = cleanTimeValues.openTags.findTag(tagName);

                    if (matchingPosition != null) {
                        final List closed = closeSnippet(nodeList, matchingPosition, endTagToken, cleanTimeValues);
                        nodeIterator.set(null);
                        for (int i = closed.size() - 1; i >= 1; i--) {
                            final TagNode closedTag = (TagNode) closed.get(i);
                            if (tag != null && tag.isContinueAfter(closedTag.getName())) {
                                nodeIterator.add(makeTagNodeCopy(closedTag, cleanTimeValues));
                                nodeIterator.previous();
                            }
                        }
                    } else if (!isAllowedInLastOpenTag(token, cleanTimeValues)) {
                        saveToLastOpenTag(nodeList, token, cleanTimeValues);
                        nodeIterator.set(null);
                    }
                }
            } else if (isStartToken(token)) {
                final TagNode startTagToken = (TagNode) token;
                final String tagName = startTagToken.getName();
                final TagInfo tag = tagInfoProvider.getTagInfo(tagName);

                final TagPos lastTagPos = cleanTimeValues.openTags.isEmpty() ? null : cleanTimeValues.openTags
                        .getLastTagPos();
                final TagInfo lastTagInfo = lastTagPos == null ? null : tagInfoProvider.getTagInfo(lastTagPos.name);

                // add tag to set of all tags
                cleanTimeValues.allTags.add(tagName);

                // HTML open tag
                if ("html".equals(tagName)) {
                    addAttributesToTag(cleanTimeValues.htmlNode, startTagToken.getAttributes());
                    nodeIterator.set(null);
                    // BODY open tag
                } else if ("body".equals(tagName)) {
                    cleanTimeValues.bodyOpened = true;
                    addAttributesToTag(cleanTimeValues.bodyNode, startTagToken.getAttributes());
                    nodeIterator.set(null);
                    // HEAD open tag
                } else if ("head".equals(tagName)) {
                    cleanTimeValues.headOpened = true;
                    addAttributesToTag(cleanTimeValues.headNode, startTagToken.getAttributes());
                    nodeIterator.set(null);
                    // unknown HTML tag and unknown tags are not allowed
                } else if ((tag == null && properties.isOmitUnknownTags())
                        || (tag != null && tag.isDeprecated() && properties.isOmitDeprecatedTags())) {
                    nodeIterator.set(null);
                    // if current tag is unknown, unknown tags are allowed and
                    // last open tag doesn't allow any other tags in its body
                } else if (tag == null && lastTagInfo != null && !lastTagInfo.allowsAnything()) {
                    saveToLastOpenTag(nodeList, token, cleanTimeValues);
                    nodeIterator.set(null);
                } else if (tag != null && tag.hasPermittedTags()
                        && cleanTimeValues.openTags.someAlreadyOpen(tag.getPermittedTags())) {
                    nodeIterator.set(null);
                    // if tag that must be unique, ignore this occurence
                } else if (tag != null && tag.isUnique() && cleanTimeValues.openTags.tagEncountered(tagName)) {
                    nodeIterator.set(null);
                    // if there is no required outer tag without that this open
                    // tag is ignored
                } else if (!isFatalTagSatisfied(tag, cleanTimeValues)) {
                    nodeIterator.set(null);
                    // if there is no required parent tag - it must be added
                    // before this open tag
                } else if (mustAddRequiredParent(tag, cleanTimeValues)) {
                    final String requiredParent = tag.getRequiredParent();
                    final TagNode requiredParentStartToken = createTagNode(requiredParent, cleanTimeValues);
                    nodeIterator.previous();
                    nodeIterator.add(requiredParentStartToken);
                    nodeIterator.previous();
                    // if last open tag has lower presidence then this, it must
                    // be closed
                } else if (tag != null && lastTagPos != null && tag.isMustCloseTag(lastTagInfo)) {
                    final List closed = closeSnippet(nodeList, lastTagPos, startTagToken, cleanTimeValues);
                    final int closedCount = closed.size();

                    // it is needed to copy some tags again in front of current,
                    // if there are any
                    if (tag.hasCopyTags() && closedCount > 0) {
                        // first iterates over list from the back and collects
                        // all start tokens
                        // in sequence that must be copied
                        final ListIterator closedIt = closed.listIterator(closedCount);
                        final List toBeCopied = new ArrayList();
                        while (closedIt.hasPrevious()) {
                            final TagNode currStartToken = (TagNode) closedIt.previous();
                            if (tag.isCopy(currStartToken.getName())) {
                                toBeCopied.add(0, currStartToken);
                            } else {
                                break;
                            }
                        }

                        if (toBeCopied.size() > 0) {
                            final Iterator copyIt = toBeCopied.iterator();
                            while (copyIt.hasNext()) {
                                final TagNode currStartToken = (TagNode) copyIt.next();
                                nodeIterator.add(makeTagNodeCopy(currStartToken, cleanTimeValues));
                            }

                            // back to the previous place, before adding new
                            // start tokens
                            for (int i = 0; i < toBeCopied.size(); i++) {
                                nodeIterator.previous();
                            }
                        }
                    }

                    nodeIterator.previous();
                    // if this open tag is not allowed inside last open tag,
                    // then it must be moved to the place where it can be
                } else if (!isAllowedInLastOpenTag(token, cleanTimeValues)) {
                    saveToLastOpenTag(nodeList, token, cleanTimeValues);
                    nodeIterator.set(null);
                    // if it is known HTML tag but doesn't allow body, it is
                    // immediately closed
                } else if (tag != null && !tag.allowsBody()) {
                    final TagNode newTagNode = createTagNode(startTagToken);
                    addPossibleHeadCandidate(tag, newTagNode, cleanTimeValues);
                    nodeIterator.set(newTagNode);
                    // default case - just remember this open tag and go further
                } else {
                    cleanTimeValues.openTags.addTag(tagName, nodeIterator.previousIndex());
                }
            } else {
                if (!isAllowedInLastOpenTag(token, cleanTimeValues)) {
                    saveToLastOpenTag(nodeList, token, cleanTimeValues);
                    nodeIterator.set(null);
                }
            }
        }
    }

