  protected BaseModel(String componentName, InputStream in) throws IOException, InvalidFormatException {
    this(componentName, true);

    loadModel(in);
  }

  protected BaseModel(String componentName, File modelFile) throws IOException, InvalidFormatException  {
    this(componentName, true);

    InputStream in = new BufferedInputStream(new FileInputStream(modelFile));

    try {
      loadModel(in);
    }
    finally {
      in.close();
    }
  }

  protected BaseModel(String componentName, URL modelURL) throws IOException, InvalidFormatException  {
    this(componentName, true);

    InputStream in = new BufferedInputStream(modelURL.openStream());

    try {
      loadModel(in);
    }
    finally {
      in.close();
    }
  }

  private void loadModel(InputStream in) throws IOException, InvalidFormatException {

    if (in == null) {
      throw new IllegalArgumentException("in must not be null!");
    }

    createBaseArtifactSerializers(artifactSerializers);

    if (!in.markSupported()) {
      in = new BufferedInputStream(in);
    }

    // TODO: Discuss this solution, the buffering should
    in.mark(MODEL_BUFFER_SIZE_LIMIT);

    final ZipInputStream zip = new ZipInputStream(in);

    // The model package can contain artifacts which are serialized with 3rd party
    // serializers which are configured in the manifest file. To be able to load
    // the model the manifest must be read first, and afterwards all the artifacts
    // can be de-serialized.

    // The ordering of artifacts in a zip package is not guaranteed. The stream is first
    // read until the manifest appears, reseted, and read again to load all artifacts.

    boolean isSearchingForManifest = true;

    ZipEntry entry;
    while((entry = zip.getNextEntry()) != null && isSearchingForManifest) {

      if ("manifest.properties".equals(entry.getName())) {
        // TODO: Probably better to use the serializer here directly!
        ArtifactSerializer factory = artifactSerializers.get("properties");
        artifactMap.put(entry.getName(), factory.create(zip));
        isSearchingForManifest = false;
      }

      zip.closeEntry();
    }

    initializeFactory();

    loadArtifactSerializers();

    // The Input Stream should always be reset-able because if markSupport returns
    // false it is wrapped before hand into an Buffered InputStream
    in.reset();

    finishLoadingArtifacts(in);

    checkArtifactMap();
  }

  private void initializeFactory() throws InvalidFormatException {
    String factoryName = getManifestProperty(FACTORY_NAME);
    if (factoryName == null) {
      // load the default factory
      Class<? extends BaseToolFactory> factoryClass = getDefaultFactory();
      if(factoryClass != null) {
        this.toolFactory = BaseToolFactory.create(factoryClass, this);
      }
    } else {
      try {
        this.toolFactory = BaseToolFactory.create(factoryName, this);
      } catch (InvalidFormatException e) {
        throw new IllegalArgumentException(e);
      }
    }
  }

