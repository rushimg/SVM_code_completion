public abstract class DetailedFMeasureListener<T> implements
    EvaluationMonitor<T> {

  private int samples = 0;
  private Stats generalStats = new Stats();
  private Map<String, Stats> statsForOutcome = new HashMap<String, Stats>();

  protected abstract Span[] asSpanArray(T sample);

  public void correctlyClassified(T reference, T prediction) {
    samples++;
    // add all true positives!
    Span[] spans = asSpanArray(reference);
    for (Span span : spans) {
      addTruePositive(span.getType());
    }
  }

  public void missclassified(T reference, T prediction) {
    samples++;
    Span[] references = asSpanArray(reference);
    Span[] predictions = asSpanArray(prediction);

    Set<Span> refSet = new HashSet<Span>(Arrays.asList(references));
    Set<Span> predSet = new HashSet<Span>(Arrays.asList(predictions));

    for (Span ref : refSet) {
      if (predSet.contains(ref)) {
        addTruePositive(ref.getType());
      } else {
        addFalseNegative(ref.getType());
      }
    }

    for (Span pred : predSet) {
      if (!refSet.contains(pred)) {
        addFalsePositive(pred.getType());
      }
    }
  }

  private void addTruePositive(String type) {
    Stats s = initStatsForOutcomeAndGet(type);
    s.incrementTruePositive();
    s.incrementTarget();

    generalStats.incrementTruePositive();
    generalStats.incrementTarget();
  }

  private void addFalsePositive(String type) {
    Stats s = initStatsForOutcomeAndGet(type);
    s.incrementFalsePositive();
    generalStats.incrementFalsePositive();
  }

  private void addFalseNegative(String type) {
    Stats s = initStatsForOutcomeAndGet(type);
    s.incrementTarget();
    generalStats.incrementTarget();

  }

  private Stats initStatsForOutcomeAndGet(String type) {
    if (!statsForOutcome.containsKey(type)) {
      statsForOutcome.put(type, new Stats());
    }
    return statsForOutcome.get(type);
  }

  private static final String PERCENT = "%\u00207.2f%%";
  private static final String FORMAT = "%12s: precision: " + PERCENT
      + ";  recall: " + PERCENT + "; F1: " + PERCENT + ".";
  private static final String FORMAT_EXTRA = FORMAT
      + " [target: %3d; tp: %3d; fp: %3d]";

  public String createReport() {
    return createReport(Locale.getDefault());
  }

  public String createReport(Locale locale) {
    StringBuilder ret = new StringBuilder();
    int tp = generalStats.getTruePositives();
    int found = generalStats.getFalsePositives() + tp;
    ret.append("Evaluated " + samples + " samples with "
        + generalStats.getTarget() + " entities; found: " + found
        + " entities; correct: " + tp + ".\n");

    ret.append(String.format(locale, FORMAT, "TOTAL",
    ret.append("\n");
    SortedSet<String> set = new TreeSet<String>(new F1Comparator());
    set.addAll(statsForOutcome.keySet());
    for (String type : set) {

      ret.append(String.format(locale, FORMAT_EXTRA, type,
          statsForOutcome.get(type).getTarget(), statsForOutcome.get(type)
              .getTruePositives(), statsForOutcome.get(type)
              .getFalsePositives()));
      ret.append("\n");
    }

    return ret.toString();
  }

  @Override
  public String toString() {
    return createReport();
  }

  private double zeroOrPositive(double v) {
    if (v < 0) {
      return 0;
    }
    return v;
  }

  private class F1Comparator implements Comparator<String> {
    public int compare(String o1, String o2) {
      if (o1.equals(o2))
        return 0;
      double t1 = 0;
      double t2 = 0;

      if (statsForOutcome.containsKey(o1))
        t1 += statsForOutcome.get(o1).getFMeasure();
      if (statsForOutcome.containsKey(o2))
        t2 += statsForOutcome.get(o2).getFMeasure();

      t1 = zeroOrPositive(t1);
      t2 = zeroOrPositive(t2);

      if (t1 + t2 > 0d) {
        if (t1 > t2)
          return -1;
        return 1;
      }
      return o1.compareTo(o2);
    }

  }

