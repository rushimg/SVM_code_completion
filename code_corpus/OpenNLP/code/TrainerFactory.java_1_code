
package opennlp.tools.ml;

import java.lang.reflect.Constructor;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import opennlp.tools.ml.maxent.GIS;
import opennlp.tools.ml.maxent.quasinewton.QNTrainer;
import opennlp.tools.ml.perceptron.PerceptronTrainer;
import opennlp.tools.ml.perceptron.SimplePerceptronSequenceTrainer;
import opennlp.tools.util.ext.ExtensionLoader;
import opennlp.tools.util.ext.ExtensionNotLoadedException;

public class TrainerFactory {

  public enum TrainerType {
    EVENT_MODEL_TRAINER,
    EVENT_MODEL_SEQUENCE_TRAINER,
    SEQUENCE_TRAINER
  }

  // built-in trainers
  private static final Map<String, Class> BUILTIN_TRAINERS;

  static {
    Map<String, Class> _trainers = new HashMap<String, Class>();
    _trainers.put(GIS.MAXENT_VALUE, GIS.class);
    _trainers.put(QNTrainer.MAXENT_QN_VALUE, QNTrainer.class);
    _trainers.put(PerceptronTrainer.PERCEPTRON_VALUE, PerceptronTrainer.class);
    _trainers.put(SimplePerceptronSequenceTrainer.PERCEPTRON_SEQUENCE_VALUE,
        SimplePerceptronSequenceTrainer.class);

    BUILTIN_TRAINERS = Collections.unmodifiableMap(_trainers);
  }

  @Deprecated
  private static String getPluggableTrainerType(String className) {
    try {
      Class<?> trainerClass = Class.forName(className);
      if(trainerClass != null) {

        if (EventTrainer.class.isAssignableFrom(trainerClass)) {
          return EventTrainer.EVENT_VALUE;
        }
        else if (EventModelSequenceTrainer.class.isAssignableFrom(trainerClass)) {
          return EventModelSequenceTrainer.SEQUENCE_VALUE;
        }
        else if (SequenceTrainer.class.isAssignableFrom(trainerClass)) {
          return SequenceTrainer.SEQUENCE_VALUE;
        }
      }
    } catch (ClassNotFoundException e) {
    }

    return null;
  }

