
  //private int numCalls = 0;
  protected void getBatch(int batchSize){

//      if (numCalls == 0) {
//          randGenerator.nextInt(this.dataDimension());
//        }
//      }
//      numCalls++;

    if (thisBatch == null || thisBatch.length != batchSize){
      thisBatch = new int[batchSize];
    }

    //-----------------------------
    //Shuffled
    //-----------------------------
    if (sampleMethod == SamplingMethod.Shuffled) {
      if (shuffledArray == null) {
        shuffledArray = ArrayMath.range(0, this.dataDimension());
      }
      for(int i = 0; i<batchSize;i++){
        thisBatch[i] = shuffledArray[(curElement + i) % this.dataDimension()] ;          //Take the next batchSize points in order
      }
      curElement = (curElement + batchSize) % this.dataDimension();       //watch out for overflow

    //-----------------------------
    //RANDOM WITH REPLACEMENT
    //-----------------------------
    } else if (sampleMethod == SamplingMethod.RandomWithReplacement) {
      for(int i = 0; i<batchSize;i++){
        thisBatch[i] = randGenerator.nextInt(this.dataDimension());        //Just generate a random index
//        System.err.println("numCalls = "+(numCalls++));
      }
      //-----------------------------
      //ORDERED
      //-----------------------------
    } else if (sampleMethod == SamplingMethod.Ordered) {
      for(int i = 0; i<batchSize;i++){
        thisBatch[i] = (curElement + i) % this.dataDimension() ;          //Take the next batchSize points in order
      }
      curElement = (curElement + batchSize) % this.dataDimension();       //watch out for overflow

      //-----------------------------
      //RANDOM WITHOUT REPLACEMENT
      //-----------------------------
    } else if(sampleMethod == SamplingMethod.RandomWithoutReplacement) {
      //Declare the indices array if needed.
      if (allIndices == null || allIndices.size()!= this.dataDimension()){

        allIndices = new ArrayList<Integer>();
        for(int i=0;i<this.dataDimension();i++){
          allIndices.add(i);
        }
        Collections.shuffle(allIndices,randGenerator);
      }

      for(int i = 0; i<batchSize;i++){
        thisBatch[i] = allIndices.get((curElement + i) % allIndices.size());  //Grab the next batchSize indices
      }

      if (curElement + batchSize > this.dataDimension()){
        Collections.shuffle(Arrays.asList(allIndices),randGenerator);                   //Shuffle if we got to the end of the list
      }

      //watch out for overflow
      curElement = (curElement + batchSize) % allIndices.size();          //Rollover


    } else {
      throw new IllegalStateException("NO SAMPLING METHOD SELECTED");
    }

  }




  void stochasticEnsure(double[] x, double[] v, int batchSize){

    if (lastXBatch == null) {
      lastXBatch = new double[domainDimension()];
      System.err.println("Setting previous position (x).");
    }

    if (lastVBatch == null) {
      lastVBatch = new double[domainDimension()];
      System.err.println("Setting previous gain (v)");
    }

    if (derivative == null) {
      derivative = new double[domainDimension()];
      System.err.println("Setting Derivative.");
    }

    if (HdotV == null) {
      HdotV = new double[domainDimension()];
      System.err.println("Setting HdotV.");
    }

    if (lastBatch == null){
      lastBatch = new int[batchSize];
      System.err.println("Setting last batch");
    }
    //If we want to recalculate using the previous batch
    if(recalculatePrevBatch && batchSize == lastBatch.length){

      thisBatch = lastBatch;

    }else{

