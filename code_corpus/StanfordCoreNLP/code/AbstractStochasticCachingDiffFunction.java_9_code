     If we dont want to calculate anything we just want the last values.  This is especially usefull if you know
         the values have already been calculated, and you don't want to waste time comparing the entire
         array of x's and v's.
      if(returnPreviousValues){
        returnPreviousValues = false;
        return;
      }

      //If we dont know there are new values, and we havnt asked to recalculate then compare
      //to avoid needing to recalculate
      if( !hasNewVals && lastElement!=curElement ){
        if ((lastBatchSize==batchSize) && Arrays.equals(x, lastXBatch) && Arrays.equals(v,lastVBatch) && Arrays.equals(thisBatch,lastBatch)) {
          return;
        }
      }

      getBatch(batchSize);
    }


    copy(lastXBatch,x);
    if(lastBatch.length != batchSize){
      lastBatch = new int[batchSize];
    }
    System.arraycopy(thisBatch,0,lastBatch,0,thisBatch.length);

    if(v!=null){copy(lastVBatch,v);}
    lastBatchSize = batchSize;

    calculateStochastic(x,v,thisBatch);

    //This is used to make the function evaluation equal the true function in expectation.
    if(scaleUp){
      double ratio = ( (double) this.dataDimension()) / ( (double)batchSize) ;
      for(int i=0;i<x.length;i++){
      }
    }

    incrementBatch(batchSize);
    lastElement = curElement;

  }

