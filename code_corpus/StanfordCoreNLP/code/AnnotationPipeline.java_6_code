  public void annotate(final Iterable<Annotation> annotations, int numThreads, final Function<Annotation,Object> callback){
    // case: single thread (no point in spawning threads)
    if(numThreads == 1) {
      for(Annotation ann : annotations) {
        annotate(ann);
        callback.apply(ann);
      }
    }
    // Java's equivalent to ".map{ lambda(annotation) => annotate(annotation) }
    Iterable<Runnable> threads = new Iterable<Runnable>() {
      @Override
      public Iterator<Runnable> iterator() {
        final Iterator<Annotation> iter = annotations.iterator();
        return new Iterator<Runnable>() {
          @Override
          public boolean hasNext() {
            return iter.hasNext();
          }
          @Override
          public Runnable next() {
            if ( ! iter.hasNext()) {
              throw new NoSuchElementException();
            }
            final Annotation input = iter.next();
            return new Runnable() {
              @Override
              public void run() {
                //(logging)
                String beginningOfDocument = input.toString().substring(0,Math.min(50,input.toString().length()));
                Redwood.startTrack("Annotating \"" + beginningOfDocument + "...\"");
                //(annotate)
                annotate(input);
                //(callback)
                callback.apply(input);
                //(logging again)
                Redwood.endTrack("Annotating \"" + beginningOfDocument + "...\"");
              }
            };
          }
          @Override
          public void remove() {
            iter.remove();
          }
        };
      }
    };
    // Thread
    Redwood.Util.threadAndRun(this.getClass().getSimpleName(), threads, numThreads );
  }

