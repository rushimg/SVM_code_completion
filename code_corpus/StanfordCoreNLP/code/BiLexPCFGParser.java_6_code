  public List<ScoredObject<Tree>> getKSampledParses(int k) {
    throw new UnsupportedOperationException("BiLexPCFGParser doesn't support k sampled parses");
  }

  protected Edge tempEdge;

  protected void combine(Edge edge, Hook hook) {
    if (VERBOSE) {
      System.err.println("Combining: " + edge + " and " + hook);
    }
    // make result edge
    if (hook.isPreHook()) {
      tempEdge.start = edge.start;
      tempEdge.end = hook.end;
    } else {
      tempEdge.start = hook.start;
      tempEdge.end = edge.end;
    }
    tempEdge.state = hook.state;
    tempEdge.head = hook.head;
    tempEdge.tag = hook.tag;
    tempEdge.iScore = hook.iScore + edge.iScore;
    tempEdge.backEdge = edge;
    tempEdge.backHook = hook;
    relaxTempEdge();
  }

  protected void relaxTempEdge() {
    // if (tempEdge.iScore > scorer.iScore(tempEdge)+1e-4) {
    //   System.err.println(tempEdge+" has i "+tempEdge.iScore+" iE "+scorer.iScore(tempEdge));
    // }
    Edge resultEdge = (Edge) interner.intern(tempEdge);
    if (VERBOSE) {
      System.err.printf("Formed %s %s %.2f was %.2f better? %b\n", (resultEdge == tempEdge ? "new" : "pre-existing"), resultEdge, tempEdge.iScore, resultEdge.iScore, better(tempEdge.iScore, resultEdge.iScore));
    }
    if (resultEdge == tempEdge) {
      tempEdge = new Edge(op.testOptions.exhaustiveTest);
      discoverEdge(resultEdge);
    } else {
      if (better(tempEdge.iScore, resultEdge.iScore) && resultEdge.oScore > Double.NEGATIVE_INFINITY) {
        // we've found a better way of making an edge that may make a parse
        double back = resultEdge.iScore;
        Edge backE = resultEdge.backEdge;
        Hook backH = resultEdge.backHook;
        resultEdge.iScore = tempEdge.iScore;
        resultEdge.backEdge = tempEdge.backEdge;
        resultEdge.backHook = tempEdge.backHook;
        try {
          agenda.decreaseKey(resultEdge);
        } catch (NullPointerException e) {
          if (false) {
            System.err.println("");
            System.err.println("Old backEdge: " + backE + " i " + backE.iScore + " o " + backE.oScore + " s " + backE.score());
            System.err.println("Old backEdge: " + backE + " iE " + scorer.iScore(backE));
            System.err.println("Old backHook: " + backH + " i " + backH.iScore + " o " + backH.oScore + " s " + backH.score());
            System.err.println("New backEdge: " + tempEdge.backEdge + " i " + tempEdge.backEdge.iScore + " o " + tempEdge.backEdge.oScore + " s " + tempEdge.backEdge.score());
            System.err.println("New backEdge: " + tempEdge.backEdge + " iE " + scorer.iScore(tempEdge.backEdge));
            System.err.println("New backHook: " + tempEdge.backHook + " i " + tempEdge.backHook.iScore + " o " + tempEdge.backHook.oScore + " s " + tempEdge.backHook.score());
            System.err.println("ERROR: Formed " + resultEdge + " i " + tempEdge.iScore + " o " + resultEdge.oScore + " s " + resultEdge.score());
            System.err.println("ERROR: Formed " + resultEdge + " " + (resultEdge == tempEdge ? "new" : "old") + " " + tempEdge.iScore + " was " + back + " better? " + better(tempEdge.iScore, back));
          }
        }
      }
    }
  }

  protected void discoverEdge(Edge edge) {
    // create new edge
    edge.oScore = scorer.oScore(edge);
    agenda.add(edge);
    builtEdges++;
  }

  protected void discoverHook(Hook hook) {
    hook.oScore = buildOScore(hook);
    if (hook.oScore == Double.NEGATIVE_INFINITY) {
      relaxHook4++;
    }
    builtHooks++;
    agenda.add(hook);
  }

  protected double buildOScore(Hook hook) {
    double bestOScore = Double.NEGATIVE_INFINITY;
    Edge iTemp = new Edge(op.testOptions.exhaustiveTest);
    Edge oTemp = new Edge(op.testOptions.exhaustiveTest);
    iTemp.head = hook.head;
    iTemp.tag = hook.tag;
    iTemp.state = hook.subState;
    oTemp.head = hook.head;
    oTemp.tag = hook.tag;
    oTemp.state = hook.state;
    if (hook.isPreHook()) {
      iTemp.end = hook.start;
      oTemp.end = hook.end;
      for (int start = 0; start <= hook.head; start++) {
        iTemp.start = start;
        oTemp.start = start;
        double oScore = scorer.oScore(oTemp) + scorer.iScore(iTemp);
        //System.err.println("Score for "+hook+" is i "+iTemp+" ("+scorer.iScore(iTemp)+") o "+oTemp+" ("+scorer.oScore(oTemp)+")");
        bestOScore = SloppyMath.max(bestOScore, oScore);
      }
    } else {
      iTemp.start = hook.end;
      oTemp.start = hook.start;
      for (int end = hook.head + 1; end <= length; end++) {
        iTemp.end = end;
        oTemp.end = end;
        double oScore = scorer.oScore(oTemp) + scorer.iScore(iTemp);
        bestOScore = SloppyMath.max(bestOScore, oScore);
      }
    }
    return bestOScore;
  }

  protected Hook tempHook;

  protected void projectHooks(Edge edge) {
    // form hooks
    // POST HOOKS
    //for (Iterator rI = bg.ruleIteratorByLeftChild(edge.state);
    //      rI.hasNext(); ) {
    List<BinaryRule> ruleList = bg.ruleListByLeftChild(edge.state);
    for (int r = 0, rsz = ruleList.size(); r < rsz; r++) {
      //BinaryRule br = rI.next();
      BinaryRule br = ruleList.get(r);
      if(scorer instanceof LatticeScorer) {
      	LatticeScorer lscorer = (LatticeScorer) scorer;
      	Edge latEdge = (Edge) lscorer.convertItemSpan(new Edge(edge));
      	if (!fscorer.oPossibleL(project(br.parent), latEdge.start) || !fscorer.iPossibleL(project(br.rightChild), latEdge.end)) {
      		if (!op.testOptions.exhaustiveTest) {
      			continue;
      		}
      	}
      } else {
      	if (!fscorer.oPossibleL(project(br.parent), edge.start) || !fscorer.iPossibleL(project(br.rightChild), edge.end)) {
      		if (!op.testOptions.exhaustiveTest) {
      			continue;
      		}
      	}
      }
      for (int head = edge.end; head < length; head++) {
        // cdm Apr 2006: avoid Iterator allocation
        // for (Iterator iTWI = taggedWordList[head].iterator(); iTWI.hasNext();) {
        // IntTaggedWord iTW = (IntTaggedWord) iTWI.next();
        for (int hdi = 0, sz = taggedWordList[head].size(); hdi < sz; hdi++) {
          IntTaggedWord iTW = taggedWordList[head].get(hdi);
          int tag = iTW.tag;
          tempHook.start = edge.start;
          tempHook.end = edge.end;
          tempHook.head = head;
          tempHook.tag = tag;
          tempHook.state = br.parent;
          tempHook.subState = br.rightChild;
          if (!chart.isBuiltL(tempHook.subState, tempHook.end, tempHook.head, tempHook.tag)) {
            continue;
          }
          tempHook.iScore = edge.iScore + br.score + dparser.headScore[dparser.binDistance[head][edge.end]][head][dg.tagBin(tag)][edge.head][dg.tagBin(edge.tag)] + dparser.headStop[edge.head][dg.tagBin(edge.tag)][edge.start] + dparser.headStop[edge.head][dg.tagBin(edge.tag)][edge.end];
          tempHook.backEdge = edge;
          relaxTempHook();
        }
      }
    }
    // PRE HOOKS
    //for (Iterator<BinaryRule> rI = bg.ruleIteratorByRightChild(edge.state);
    //     rI.hasNext(); ) {
    ruleList = bg.ruleListByRightChild(edge.state);
    for (int r = 0, rlSize = ruleList.size(); r < rlSize; r++) {
      //BinaryRule br = rI.next();
      BinaryRule br = ruleList.get(r);
      if(scorer instanceof LatticeScorer) {
      	LatticeScorer lscorer = (LatticeScorer) scorer;
      	Edge latEdge = (Edge) lscorer.convertItemSpan(new Edge(edge));
      	if (!fscorer.oPossibleR(project(br.parent), latEdge.end) || !fscorer.iPossibleR(project(br.leftChild), latEdge.start)) {
      		if (!op.testOptions.exhaustiveTest) {
      			continue;
      		}
      	}
      } else {
      	if (!fscorer.oPossibleR(project(br.parent), edge.end) || !fscorer.iPossibleR(project(br.leftChild), edge.start)) {
      		if (!op.testOptions.exhaustiveTest) {
      			continue;
      		}
      	}
      }
      for (int head = 0; head < edge.start; head++) {
        // cdm Apr 2006: avoid Iterator allocation
        // for (Iterator iTWI = taggedWordList[head].iterator(); iTWI.hasNext();) {
        //IntTaggedWord iTW = (IntTaggedWord) iTWI.next();
        for (int hdi = 0, sz = taggedWordList[head].size(); hdi < sz; hdi++) {
          IntTaggedWord iTW = taggedWordList[head].get(hdi);
          int tag = iTW.tag;
          tempHook.start = edge.start;
          tempHook.end = edge.end;
          tempHook.head = head;
          tempHook.tag = tag;
          tempHook.state = br.parent;
          tempHook.subState = br.leftChild;
          if (!chart.isBuiltR(tempHook.subState, tempHook.start, tempHook.head, tempHook.tag)) {
            continue;
          }
          tempHook.iScore = edge.iScore + br.score + dparser.headScore[dparser.binDistance[head][edge.start]][head][dg.tagBin(tag)][edge.head][dg.tagBin(edge.tag)] + dparser.headStop[edge.head][dg.tagBin(edge.tag)][edge.start] + dparser.headStop[edge.head][dg.tagBin(edge.tag)][edge.end];
          tempHook.backEdge = edge;
          relaxTempHook();
        }
      }
    }
  }

  protected void registerReal(Edge real) {
    chart.registerRealEdge(real);
  }

  protected void triggerHooks(Edge edge) {
    // we might have built a synth edge, enabling some old real edges to project hooks (the difference between this method and triggerAllHooks is that here we look only at realEdges)
    boolean newL = !chart.isBuiltL(edge.state, edge.start, edge.head, edge.tag);
    boolean newR = !chart.isBuiltR(edge.state, edge.end, edge.head, edge.tag);
    if (VERY_VERBOSE) {
      if (newL) {
        System.err.println("Triggering on L: " + edge);
      }
      if (newR) {
        System.err.println("Triggering on R: " + edge);
      }
    }
    chart.registerEdgeIndexes(edge);
    if (newR) {
      // PRE HOOKS
      BinaryRule[] rules = bg.splitRulesWithLC(edge.state);
      for (BinaryRule br : rules) {
        Collection<Edge> realEdges = chart.getRealEdgesWithL(br.rightChild, edge.end);
        for (Edge real : realEdges) {
          tempHook.start = real.start;
          tempHook.end = real.end;
          tempHook.state = br.parent;
          tempHook.subState = br.leftChild;
          tempHook.head = edge.head;
          tempHook.tag = edge.tag;
          tempHook.backEdge = real;
          tempHook.iScore = real.iScore + br.score + dparser.headScore[dparser.binDistance[edge.head][edge.end]][edge.head][dg.tagBin(edge.tag)][real.head][dg.tagBin(real.tag)] + dparser.headStop[real.head][dg.tagBin(real.tag)][real.start] + dparser.headStop[real.head][dg.tagBin(real.tag)][real.end];
          relaxTempHook();
        }
      }
    }
    if (newL) {
      // POST HOOKS
      BinaryRule[] rules = bg.splitRulesWithRC(edge.state);
      for (BinaryRule br : rules) {
        Collection<Edge> realEdges = chart.getRealEdgesWithR(br.leftChild, edge.start);
        for (Edge real : realEdges) {
          tempHook.start = real.start;
          tempHook.end = real.end;
          tempHook.state = br.parent;
          tempHook.subState = br.rightChild;
          tempHook.head = edge.head;
          tempHook.tag = edge.tag;
          tempHook.backEdge = real;
          tempHook.iScore = real.iScore + br.score + dparser.headScore[dparser.binDistance[edge.head][edge.start]][edge.head][dg.tagBin(edge.tag)][real.head][dg.tagBin(real.tag)] + dparser.headStop[real.head][dg.tagBin(real.tag)][real.start] + dparser.headStop[real.head][dg.tagBin(real.tag)][real.end];
          relaxTempHook();
        }
      }
    }
  }

  protected void triggerAllHooks(Edge edge) {
    // we might have built a new edge, enabling some old edges to project hooks
    boolean newL = !chart.isBuiltL(edge.state, edge.start, edge.head, edge.tag);
    boolean newR = !chart.isBuiltR(edge.state, edge.end, edge.head, edge.tag);
    if (VERY_VERBOSE) {
      if (newL) {
        System.err.println("Triggering on L: " + edge);
      }
      if (newR) {
        System.err.println("Triggering on R: " + edge);
      }
    }
    chart.registerEdgeIndexes(edge);
    if (newR) {
      // PRE HOOKS
      for (Iterator<BinaryRule> rI = bg.ruleIteratorByLeftChild(edge.state); rI.hasNext();) {
        BinaryRule br = rI.next();
        Collection<Edge> edges = chart.getRealEdgesWithL(br.rightChild, edge.end);
        for (Edge real : edges) {
          tempHook.start = real.start;
          tempHook.end = real.end;
          tempHook.state = br.parent;
          tempHook.subState = br.leftChild;
          tempHook.head = edge.head;
          tempHook.tag = edge.tag;
          tempHook.backEdge = real;
          tempHook.iScore = real.iScore + br.score + dparser.headScore[dparser.binDistance[edge.head][edge.end]][edge.head][dg.tagBin(edge.tag)][real.head][dg.tagBin(real.tag)] + dparser.headStop[real.head][dg.tagBin(real.tag)][real.start] + dparser.headStop[real.head][dg.tagBin(real.tag)][real.end];
          relaxTempHook();
        }
      }
    }
    if (newL) {
      // POST HOOKS
      for (Iterator rI = bg.ruleIteratorByRightChild(edge.state); rI.hasNext();) {
        BinaryRule br = (BinaryRule) rI.next();
        Collection<Edge> edges = chart.getRealEdgesWithR(br.leftChild, edge.start);
        if (VERBOSE) {
          System.err.println("Looking for: " + stateIndex.get(br.leftChild) + " ending at " + edge.start);
          System.err.println("Found: " + edges);
        }
        for (Edge real : edges) {
          tempHook.start = real.start;
          tempHook.end = real.end;
          tempHook.state = br.parent;
          tempHook.subState = br.rightChild;
          tempHook.head = edge.head;
          tempHook.tag = edge.tag;
          tempHook.backEdge = real;
          tempHook.iScore = real.iScore + br.score + dparser.headScore[dparser.binDistance[edge.head][edge.start]][edge.head][dg.tagBin(edge.tag)][real.head][dg.tagBin(real.tag)] + dparser.headStop[real.head][dg.tagBin(real.tag)][real.start] + dparser.headStop[real.head][dg.tagBin(real.tag)][real.end];
          relaxTempHook();
        }
      }
    }
  }


  protected void relaxTempHook() {
    relaxHook1++;
    if (VERBOSE) {
      System.err.println("Considering: " + tempHook + " iP: " + scorer.iPossible(tempHook) + " oP: " + scorer.oPossible(tempHook));
    }
    if (!op.testOptions.exhaustiveTest) {
      if (!scorer.oPossible(tempHook) || !scorer.iPossible(tempHook)) {
        return;
      }
    }
    relaxHook2++;
    Hook resultHook = (Hook) interner.intern(tempHook);
    if (VERBOSE) {
      System.err.printf("Formed %s %s %f was %f\n", resultHook, (resultHook == tempHook ? "new" : "old"), tempHook.iScore, resultHook.iScore);
      if (resultHook.backEdge != null) {
        System.err.println("  Backtrace: " + resultHook.backEdge);
      }
    }
    if (resultHook == tempHook) {
      relaxHook3++;
      tempHook = new Hook(op.testOptions.exhaustiveTest);
      discoverHook(resultHook);
    }
    if (better(tempHook.iScore, resultHook.iScore)) {
      resultHook.iScore = tempHook.iScore;
      resultHook.backEdge = tempHook.backEdge;
      try {
        agenda.decreaseKey(resultHook);
      } catch (NullPointerException e) {
      }
    }
  }

  protected void projectUnaries(Edge edge) {
    for (Iterator rI = ug.ruleIteratorByChild(edge.state); rI.hasNext();) {
      UnaryRule ur = (UnaryRule) rI.next();
      if (ur.child == ur.parent) {
        continue;
      }
      tempEdge.start = edge.start;
      tempEdge.end = edge.end;
      tempEdge.head = edge.head;
      tempEdge.tag = edge.tag;
      tempEdge.state = ur.parent;
      tempEdge.backEdge = edge;
      tempEdge.backHook = null;
      tempEdge.iScore = edge.iScore + ur.score;
      relaxTempEdge();
    }
  }

  protected void processEdge(Edge edge) {
    // add to chart
    if (VERBOSE) {
      System.err.println("Adding to chart: " + edge);
    }
    chart.addEdge(edge);
    // fetch existing hooks that can combine with it and combine them
    for (Hook hook : chart.getPreHooks(edge)) {
      combine(edge, hook);
    }
    for (Hook hook : chart.getPostHooks(edge)) {
      combine(edge, hook);
    }
    // do projections
    //if (VERBOSE) System.err.println("Projecting: "+edge);
    projectUnaries(edge);
    if (!bg.isSynthetic(edge.state) && !op.freeDependencies) {
      projectHooks(edge);
      registerReal(edge);
    }
    if (op.freeDependencies) {
      projectHooks(edge);
      registerReal(edge);
      triggerAllHooks(edge);
    } else {
      triggerHooks(edge);
    }
  }

  protected void processHook(Hook hook) {
    // add to chart
    //if (VERBOSE) System.err.println("Adding to chart: "+hook);
    chart.addHook(hook);
    Collection<Edge> edges = chart.getEdges(hook);
    for (Edge edge : edges) {
      combine(edge, hook);
    }
  }

  protected void processItem(Item item) {
    if (item.isEdge()) {
      processEdge((Edge) item);
    } else {
      processHook((Hook) item);
    }
  }

  protected void discoverItem(Item item) {
    if (item.isEdge()) {
      discoverEdge((Edge) item);
    } else {
      discoverHook((Hook) item);
    }
  }

  protected Item makeInitialItem(int pos, int tag, int state, double iScore) {
    Edge edge = new Edge(op.testOptions.exhaustiveTest);
    edge.start = pos;
    edge.end = pos + 1;
    edge.state = state;
    edge.head = pos;
    edge.tag = tag;
    edge.iScore = iScore;
    return edge;
  }

  protected List<Item> makeInitialItems(List<? extends HasWord> wordList) {
    List<Item> itemList = new ArrayList<Item>();
    int length = wordList.size();
    int numTags = tagIndex.size();
    words = new int[length];
    taggedWordList = new List[length];
    int terminalCount = 0;
    originalLabels = new CoreLabel[wordList.size()];
    for (int i = 0; i < length; i++) {
      taggedWordList[i] = new ArrayList<IntTaggedWord>(numTags);
      HasWord wordObject = wordList.get(i);
      if (wordObject instanceof CoreLabel) {
        originalLabels[i] = (CoreLabel) wordObject;
      }
      String wordStr = wordObject.word();

      //Word context (e.g., morphosyntactic info)
      String wordContextStr = null;
      if(wordObject instanceof HasContext) {
        wordContextStr = ((HasContext) wordObject).originalText();
        if("".equals(wordContextStr))
          wordContextStr = null;
      }

      if (!wordIndex.contains(wordStr)) {
        wordStr = Lexicon.UNKNOWN_WORD;
      }
      int word = wordIndex.indexOf(wordStr);
      words[i] = word;
      for (Iterator<IntTaggedWord> tagI = lex.ruleIteratorByWord(word, i, wordContextStr); tagI.hasNext(); ) {
        IntTaggedWord tagging = tagI.next();
        int tag = tagging.tag;
        //String curTagStr = tagIndex.get(tag);
        //if (!tagStr.equals("") && !tagStr.equals(curTagStr))
        //  continue;
        int state = stateIndex.indexOf(tagIndex.get(tag));
        tempEdge.state = state;
        tempEdge.head = i;
        tempEdge.start = i;
        tempEdge.end = i + 1;
        tempEdge.tag = tag;
        itemList.add(makeInitialItem(i, tag, state, scorer.iScore(tempEdge)));
        terminalCount++;
        taggedWordList[i].add(new IntTaggedWord(word, tag));
      }
    }
    if (op.testOptions.verbose) {
      System.err.println("Terminals (# of tag edges in chart): " +
                         terminalCount);
    }
    return itemList;
  }

  protected void scoreDependencies() {
    // just leach it off the dparser for now...
