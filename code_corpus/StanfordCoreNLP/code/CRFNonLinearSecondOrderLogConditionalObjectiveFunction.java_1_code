  List<Index<CRFLabel>> labelIndices;
  Index<String> classIndex;  // didn't have <String> before. Added since that's what is assumed everywhere.
  double[][] Ehat; // empirical counts of all the linear features [feature][class]
  double[][] Uhat; // empirical counts of all the output layer features [num of class][input layer size]
  double[][] What; // empirical counts of all the input layer features [input layer size][featureIndex.size()]
  int window;
  int numClasses;
  int numHiddenUnits;
  int[] map;
  int[][][][] data;  // data[docIndex][tokenIndex][][]
  int[][] docWindowLabels;

  int[][] labels;    // labels[docIndex][tokenIndex]
  int domainDimension = -1;
  int inputLayerSize = -1;
  int outputLayerSize = -1;
  int inputLayerSize4Edge= -1;
  int outputLayerSize4Edge = -1;

  int edgeParamCount = -1;
  int numNodeFeatures = -1;
  int numEdgeFeatures = -1;
  int beforeOutputWeights = -1;

  // for debugging
  int originalFeatureCount = -1;

  int[][] weightIndices;

  String crfType = "maxent";
  String backgroundSymbol;

  public static boolean VERBOSE = false;

  public static int getPriorType(String priorTypeStr)
  {
    if (priorTypeStr == null) return QUADRATIC_PRIOR;  // default
    if ("QUADRATIC".equalsIgnoreCase(priorTypeStr)) {
      return QUADRATIC_PRIOR;
    } else if ("HUBER".equalsIgnoreCase(priorTypeStr)) {
      return HUBER_PRIOR;
    } else if ("QUARTIC".equalsIgnoreCase(priorTypeStr)) {
      return QUARTIC_PRIOR;
    } else if (priorTypeStr.equalsIgnoreCase("NONE")) {
      return NO_PRIOR;
    } else {
      throw new IllegalArgumentException("Unknown prior type: " + priorTypeStr);
    }
  }

  CRFNonLinearSecondOrderLogConditionalObjectiveFunction(int[][][][] data, int[][] labels, int window, Index classIndex, List<Index<CRFLabel>> labelIndices, int[] map, SeqClassifierFlags flags, int numNodeFeatures, int numEdgeFeatures) {
    this(data, labels, window, classIndex, labelIndices, map, QUADRATIC_PRIOR, flags, numNodeFeatures, numEdgeFeatures);
  }

  CRFNonLinearSecondOrderLogConditionalObjectiveFunction(int[][][][] data, int[][] labels, int window, Index<String> classIndex, List<Index<CRFLabel>> labelIndices, int[] map, int prior, SeqClassifierFlags flags, int numNodeFeatures, int numEdgeFeatures) {
    this.window = window;
    this.classIndex = classIndex;
    this.numClasses = classIndex.size();
    this.labelIndices = labelIndices;
    this.data = data;
    this.flags = flags;
    this.map = map;
    this.labels = labels;
    this.prior = prior;
    this.backgroundSymbol = flags.backgroundSymbol;
    this.sigma = flags.sigma;
    this.outputLayerSize = numClasses;
    this.numHiddenUnits = flags.numHiddenUnits;
    this.numNodeFeatures = numNodeFeatures;
    this.numEdgeFeatures = numEdgeFeatures;
    this.useOutputLayer = flags.useOutputLayer;
    this.useHiddenLayer = flags.useHiddenLayer;
    this.useSigmoid = flags.useSigmoid;
    this.docWindowLabels = new int[data.length][];
    if (!useOutputLayer) {
      System.err.println("Output layer not activated, inputLayerSize must be equal to numClasses, setting it to " + numClasses);
      this.inputLayerSize = numClasses;
    } else if (flags.softmaxOutputLayer && !(flags.sparseOutputLayer || flags.tieOutputLayer)) {
      throw new RuntimeException("flags.softmaxOutputLayer == true, but neither flags.sparseOutputLayer or flags.tieOutputLayer is true");
    }
    // empiricalCounts();
  }

  @Override
  public int domainDimension() {
    if (domainDimension < 0) {
      originalFeatureCount = 0;
      for (int i = 0; i < map.length; i++) {
        int s = labelIndices.get(map[i]).size();
        originalFeatureCount += s;
      }
      domainDimension = 0;
      beforeOutputWeights = domainDimension;
      if (useOutputLayer) {
        if (flags.sparseOutputLayer) {
        } else if (flags.tieOutputLayer) {
        } else {
        }
      }
      System.err.println("originalFeatureCount: "+originalFeatureCount);
      System.err.println("beforeOutputWeights: "+beforeOutputWeights);
      System.err.println("domainDimension: "+domainDimension);
    }
    return domainDimension;
  }

  @Override 
  public double[] initial() {
    double[] initial = new double[domainDimension()];
    // randomly initialize weights
    if (useHiddenLayer || useOutputLayer) {
      double epsilon = 0.1;
      int count = 0;
      double val = 0;

      if (flags.blockInitialize) {
        int interval4Edge = numEdgeFeatures / numHiddenUnits;
        for (int i = 0; i < numHiddenUnits; i++) {
          if (i == numHiddenUnits - 1)
            upper = numEdgeFeatures;
          for (int j = 0; j < outputLayerSize4Edge; j++) {
            for (int k = 0; k < numEdgeFeatures; k++) {
              val = 0;
              if (k >= lower && k < upper) {
              }
              initial[count++] = val;
            }
          }
        }

        int interval = numNodeFeatures / numHiddenUnits;
        for (int i = 0; i < numHiddenUnits; i++) {
          if (i == numHiddenUnits - 1)
            upper = numNodeFeatures;
          for (int j = 0; j < outputLayerSize; j++) {
            for (int k = 0; k < numNodeFeatures; k++) {
              val = 0;
              if (k >= lower && k < upper) {
              }
              initial[count++] = val;
            }
          }
        }
        if (count != beforeOutputWeights) {
          throw new RuntimeException("after blockInitialize, param Index (" + count + ") not equal to beforeOutputWeights (" + beforeOutputWeights + ")");
        }
      } else {
        for (int i = 0; i < beforeOutputWeights; i++) {
          initial[count++] = val;
        }
      }

      if (flags.sparseOutputLayer) {
        for (int i = 0; i < outputLayerSize4Edge; i++) {
          double total = 1;
          for (int j = 0; j < numHiddenUnits-1; j++) {
            initial[count++] = val;
            total -= val;
          }
          initial[count++] = total;
        }
        for (int i = 0; i < outputLayerSize; i++) {
          double total = 1;
          for (int j = 0; j < numHiddenUnits-1; j++) {
            initial[count++] = val;
            total -= val;
          }
          initial[count++] = total;
        }
      } else if (flags.tieOutputLayer) {
        double total = 1;
        double sum = 0;
        for (int j = 0; j < numHiddenUnits-1; j++) {
          initial[count++] = val;
          total -= val;
        }
        initial[count++] = total;
        total = 1;
        sum = 0;
        for (int j = 0; j < numHiddenUnits-1; j++) {
          initial[count++] = val;
          total -= val;
        }
        initial[count++] = total;
      } else {
        for (int i = beforeOutputWeights; i < domainDimension(); i++) {
          initial[count++] = val;
        }
      }
      if (count != domainDimension()) {
        throw new RuntimeException("after param initialization, param Index (" + count + ") not equal to domainDimension (" + domainDimension() + ")");
      }
    }
    return initial;
  }

  private double[][] emptyU4Edge() {
    int innerSize = inputLayerSize4Edge;
    if (flags.sparseOutputLayer || flags.tieOutputLayer) {
      innerSize = numHiddenUnits;
    }
    int outerSize = outputLayerSize4Edge;
    if (flags.tieOutputLayer) {
      outerSize = 1;
    }

    double[][] temp = new double[outerSize][innerSize];
    for (int i = 0; i < outerSize; i++) {
      temp[i] = new double[innerSize];
    }
    return temp;
  }

  private double[][] emptyW4Edge() {
    double[][] temp = new double[inputLayerSize4Edge][numEdgeFeatures];
    for (int i = 0; i < inputLayerSize; i++) {
      temp[i] = new double[numEdgeFeatures];
    }
    return temp;
  }

  private double[][] emptyU() {
    int innerSize = inputLayerSize;
    if (flags.sparseOutputLayer || flags.tieOutputLayer) {
      innerSize = numHiddenUnits;
    }
    int outerSize = outputLayerSize;
    if (flags.tieOutputLayer) {
      outerSize = 1;
    }

    double[][] temp = new double[outerSize][innerSize];
    for (int i = 0; i < outerSize; i++) {
      temp[i] = new double[innerSize];
    }
    return temp;
  }

  private double[][] emptyW() {
    double[][] temp = new double[inputLayerSize][numNodeFeatures];
    for (int i = 0; i < inputLayerSize; i++) {
      temp[i] = new double[numNodeFeatures];
    }
    return temp;
  }

  public Quadruple<double[][], double[][], double[][], double[][]> separateWeights(double[] x) {
    int index = 0;
    double[][] inputLayerWeights4Edge = emptyW4Edge();
    for (int i = 0; i < inputLayerWeights4Edge.length; i++) {
      for (int j = 0; j < inputLayerWeights4Edge[i].length; j++) {
        inputLayerWeights4Edge[i][j] = x[index++];
      }
    }

    double[][] inputLayerWeights = emptyW();
    for (int i = 0; i < inputLayerWeights.length; i++) {
      for (int j = 0; j < inputLayerWeights[i].length; j++) {
        inputLayerWeights[i][j] = x[index++];
      }
    }

    double[][] outputLayerWeights4Edge = emptyU4Edge();
    for (int i = 0; i < outputLayerWeights4Edge.length; i++) {
      for (int j = 0; j < outputLayerWeights4Edge[i].length; j++) {
        if (useOutputLayer)
          outputLayerWeights4Edge[i][j] = x[index++];
        else
          outputLayerWeights4Edge[i][j] = 1;
      }
    }

    double[][] outputLayerWeights = emptyU();
    for (int i = 0; i < outputLayerWeights.length; i++) {
      for (int j = 0; j < outputLayerWeights[i].length; j++) {
        if (useOutputLayer)
          outputLayerWeights[i][j] = x[index++];
        else
          outputLayerWeights[i][j] = 1;
      }
    }
    assert(index == x.length);
    return new Quadruple<double[][], double[][], double[][], double[][]>(inputLayerWeights4Edge, outputLayerWeights4Edge, inputLayerWeights, outputLayerWeights);
  }

  public CliquePotentialFunction getCliquePotentialFunction(double[] x) {
    Quadruple<double[][], double[][], double[][], double[][]> allParams = separateWeights(x);
    double[][] W4Edge = allParams.first(); // inputLayerWeights4Edge
    double[][] U4Edge = allParams.second(); // outputLayerWeights4Edge
    double[][] W = allParams.third(); // inputLayerWeights 
    double[][] U = allParams.fourth(); // outputLayerWeights 
    return new NonLinearSecondOrderCliquePotentialFunction(W4Edge, U4Edge, W, U, flags);
  }


  // todo [cdm]: Below data[m] --> docData
