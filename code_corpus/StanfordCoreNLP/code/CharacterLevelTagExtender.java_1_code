public class CharacterLevelTagExtender extends BobChrisTreeNormalizer implements TreeTransformer {

  private static final long serialVersionUID = 7893996593626523700L;

  private static final boolean useTwoCharTags = false;

  public CharacterLevelTagExtender() {
    super(new ChineseTreebankLanguagePack());
  }

  public CharacterLevelTagExtender(TreebankLanguagePack tlp) {
    super(tlp);
  }

  @Override
  public Tree normalizeWholeTree(Tree tree, TreeFactory tf) {
    return transformTree(super.normalizeWholeTree(tree,tf));
  }

  //  static Set preterminals = new HashSet();

  public Tree transformTree(Tree tree) {
    TreeFactory tf = tree.treeFactory();
    String tag = tree.label().value();
    if (tree.isPreTerminal()) {
      String word = tree.firstChild().label().value();

      List<Tree> newPreterms = new ArrayList<Tree>();
      for (int i = 0, size = word.length(); i < size; i++) {
        String singleCharLabel = new String(new char[]{word.charAt(i)});
        Tree newLeaf = tf.newLeaf(singleCharLabel);
        String suffix;
        if (useTwoCharTags) {
          if (word.length() == 1 || i == 0) {
            suffix = "_S";
          } else {
            suffix = "_M";
          }
        } else {
          if (word.length() == 1) {
            suffix = "_S";
          } else if (i == 0) {
            suffix = "_B";
          } else if (i == word.length() - 1) {
            suffix = "_E";
          } else {
            suffix = "_M";
          }
        }
        newPreterms.add(tf.newTreeNode(tag + suffix, Collections.<Tree>singletonList(newLeaf)));
      }
      return tf.newTreeNode(tag, newPreterms);
    } else {
      List<Tree> newChildren = new ArrayList<Tree>();
      for (int i = 0; i < tree.children().length; i++) {
        Tree child = tree.children()[i];
        newChildren.add(transformTree(child));
      }
      return tf.newTreeNode(tag, newChildren);
    }
  }

  public Tree untransformTree(Tree tree) {
    TreeFactory tf = tree.treeFactory();
    if (tree.isPrePreTerminal()) {
        StringBuilder word = new StringBuilder();
        for (int i = 0; i < tree.children().length; i++) {
          Tree child = tree.children()[i];
          word.append(child.firstChild().label().value());
        }
        Tree newChild = tf.newLeaf(word.toString());
        tree.setChildren(Collections.singletonList(newChild));
      }
    } else {
      for (int i = 0; i < tree.children().length; i++) {
        Tree child = tree.children()[i];
        untransformTree(child);
      }
    }
    return tree;
  }

  private static void testTransAndUntrans(CharacterLevelTagExtender e, Treebank tb, PrintWriter pw) {
    for (Tree tree : tb) {
      Tree oldTree = tree.treeSkeletonCopy();
      e.transformTree(tree);
      e.untransformTree(tree);
      if (!tree.equals(oldTree)) {
        pw.println("NOT EQUAL AFTER UNTRANSFORMATION!!!");
        pw.println();
        oldTree.pennPrint(pw);
        pw.println();
        tree.pennPrint(pw);
        pw.println("------------------");
      }
    }
  }

