public class CollinsDepEval extends AbstractEval {

  private static final boolean DEBUG = false;

  private final HeadFinder hf;
  private final String startSymbol;

  private final Counter<CollinsRelation> precisions;
  private final Counter<CollinsRelation> recalls;
  private final Counter<CollinsRelation> f1s;

  private final Counter<CollinsRelation> precisions2;
  private final Counter<CollinsRelation> recalls2;
  private final Counter<CollinsRelation> pnums2;
  private final Counter<CollinsRelation> rnums2;

  public CollinsDepEval(String str, boolean runningAverages, HeadFinder hf, String startSymbol) {
    super(str,runningAverages);

    this.hf = hf;
    this.startSymbol = startSymbol;

    precisions = new ClassicCounter<CollinsRelation>();
    recalls = new ClassicCounter<CollinsRelation>();
    f1s = new ClassicCounter<CollinsRelation>();

    precisions2 = new ClassicCounter<CollinsRelation>();
    recalls2 = new ClassicCounter<CollinsRelation>();
    pnums2 = new ClassicCounter<CollinsRelation>();
    rnums2 = new ClassicCounter<CollinsRelation>();
  }

  @Override
  protected Set<?> makeObjects(Tree tree) {
    System.err.println(this.getClass().getName() + ": Function makeObjects() not implemented");
    return null;
  }

  private Map<CollinsRelation,Set<CollinsDependency>> makeCollinsObjects(Tree t) {
    final Map<CollinsRelation,Set<CollinsDependency>> relMap = Generics.newHashMap();
    final Set<CollinsDependency> deps = CollinsDependency.extractNormalizedFromTree(t, startSymbol, hf);

    for(CollinsDependency dep : deps) {
      if(DEBUG) System.out.println(dep.toString());
      if(relMap.get(dep.getRelation()) == null)
        relMap.put(dep.getRelation(), Generics.<CollinsDependency>newHashSet());
      relMap.get(dep.getRelation()).add(dep);
    }
    if(DEBUG) System.out.println();

    return relMap;
  }

  @Override
  public void evaluate(Tree guess, Tree gold, PrintWriter pw) {
    if(gold == null || guess == null) {
      System.err.printf("%s: Cannot compare against a null gold or guess tree!\n",this.getClass().getName());
      return;
    }

    if(DEBUG) System.out.println("guess:");
    Map<CollinsRelation,Set<CollinsDependency>> guessDeps = makeCollinsObjects(guess);

    if(DEBUG) System.out.println("gold:");
    Map<CollinsRelation,Set<CollinsDependency>> goldDeps = makeCollinsObjects(gold);

    Set<CollinsRelation> relations = Generics.newHashSet();
    relations.addAll(guessDeps.keySet());
    relations.addAll(goldDeps.keySet());

    num += 1.0;

    for (CollinsRelation rel : relations) {
      Set<CollinsDependency> thisGuessDeps = guessDeps.get(rel);
      Set<CollinsDependency> thisGoldDeps = goldDeps.get(rel);

      if (thisGuessDeps == null)
        thisGuessDeps = Generics.newHashSet();
      if (thisGoldDeps == null)
        thisGoldDeps = Generics.newHashSet();

      double currentPrecision = precision(thisGuessDeps, thisGoldDeps);
      double currentRecall = precision(thisGoldDeps, thisGuessDeps);
      double currentF1 = (currentPrecision > 0.0 && currentRecall > 0.0 ? 2.0 / (1.0 / currentPrecision + 1.0 / currentRecall) : 0.0);

      precisions.incrementCount(rel, currentPrecision);
      recalls.incrementCount(rel, currentRecall);
      f1s.incrementCount(rel, currentF1);

      pnums2.incrementCount(rel, thisGuessDeps.size());

      rnums2.incrementCount(rel, thisGoldDeps.size());

      if (pw != null && runningAverages) {
        double cF1 = 2.0 / (rnums2.getCount(rel) / recalls2.getCount(rel) + pnums2.getCount(rel) / precisions2.getCount(rel));
        pw.println(emit);
      }
    }
    if (pw != null && runningAverages) {
      pw.println("================================================================================");
    }
  }

  @Override
  public void display(boolean verbose, PrintWriter pw) {
    final NumberFormat nf = new DecimalFormat("0.00");
    final Set<CollinsRelation> cats = Generics.newHashSet();
    final Random rand = new Random();
    cats.addAll(precisions.keySet());
    cats.addAll(recalls.keySet());

    Map<Double,CollinsRelation> f1Map = new TreeMap<Double,CollinsRelation>();
    for (CollinsRelation cat : cats) {
      double pnum2 = pnums2.getCount(cat);
      double rnum2 = rnums2.getCount(cat);
      double prec = precisions2.getCount(cat) / pnum2;//(num > 0.0 ? precision/num : 0.0);
      double rec = recalls2.getCount(cat) / rnum2;//(num > 0.0 ? recall/num : 0.0);
      double f1 = 2.0 / (1.0 / prec + 1.0 / rec);//(num > 0.0 ? f1/num : 0.0);

      if(new Double(f1).equals(Double.NaN)) f1 = -1.0;
      if(f1Map.containsKey(f1))
        f1Map.put(f1 + (rand.nextDouble()/1000.0), cat);
      else
        f1Map.put(f1, cat);
    }

    pw.println(" Abstract Collins Dependencies -- final statistics");
    pw.println("================================================================================");

    for (CollinsRelation cat : f1Map.values()) {
      double pnum2 = pnums2.getCount(cat);
      double rnum2 = rnums2.getCount(cat);
      double prec = precisions2.getCount(cat) / pnum2;//(num > 0.0 ? precision/num : 0.0);
      double rec = recalls2.getCount(cat) / rnum2;//(num > 0.0 ? recall/num : 0.0);
      double f1 = 2.0 / (1.0 / prec + 1.0 / rec);//(num > 0.0 ? f1/num : 0.0);

      pw.println(cat + "\tLP: " + ((pnum2 == 0.0) ? " N/A": nf.format(prec)) + "\tguessed: " + (int) pnum2 +
          "\tLR: " + ((rnum2 == 0.0) ? " N/A": nf.format(rec)) + "\tgold:  " + (int) rnum2 +
          "\tF1: " + ((pnum2 == 0.0 || rnum2 == 0.0) ? " N/A": nf.format(f1)));
    }

    pw.println("================================================================================");
  }

  private final static int MIN_ARGS = 2;
  private static String usage() {
    StringBuilder usage = new StringBuilder();
    String nl = System.getProperty("line.separator");
    usage.append(String.format("Usage: java %s [OPTS] goldFile guessFile%n%n",CollinsDepEval.class.getName()));
    usage.append("Options:").append(nl);
    usage.append("  -v        : Verbose output").append(nl);
    usage.append("  -l lang   : Language name " + Languages.listOfLanguages()).append(nl);
    usage.append("  -y num    : Max yield of gold trees").append(nl);
    usage.append("  -g num    : Max yield of guess trees").append(nl);
    return usage.toString();
  }
  private static Map<String,Integer> optionArgDefs() {
    Map<String,Integer> optionArgDefs = Generics.newHashMap();
    optionArgDefs.put("v", 0);
    optionArgDefs.put("l", 1);
    optionArgDefs.put("g", 1);
    optionArgDefs.put("y", 1);
    return optionArgDefs;
  }

