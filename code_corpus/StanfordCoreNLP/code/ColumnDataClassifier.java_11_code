  private Pair<Double, Double> testExamples(Classifier<String, String> cl, GeneralDataset<String, String> test, List<String[]> lineInfos) {
    System.err.print("Output format: ");
    if (globalFlags.displayedColumn >= 0) {
      System.err.printf("dataColumn%d\t", globalFlags.displayedColumn);
    }
    System.err.print("goldAnswer\t");
    if (globalFlags.displayAllAnswers) {
      System.err.println("[P(class) class]+ {sorted by probability}");
    } else {
      System.err.println("classifierAnswer\tP(clAnswer)\tP(goldAnswer)");
    }

    Counter<String> contingency = new ClassicCounter<String>();  // store tp,fp,fn,tn
    for (int i = 0, sz = test.size(); i < sz; i++) {
      String[] simpleLineInfo = lineInfos.get(i);
      Datum<String,String> d;
      if (globalFlags.usesRealValues) {
        d = test.getRVFDatum(i);
      } else {
        d = test.getDatum(i);
      }
      if (globalFlags.justify) {
        System.err.println("### Test item " + i);
        for (String field : simpleLineInfo) {
          System.err.print(field);
          System.err.print('\t');
        }
        System.err.println();
        if (cl instanceof LinearClassifier) {
          ((LinearClassifier<String,String>)cl).justificationOf(d);
        }
        System.err.println();
      }
      Counter<String> logScores;
      if (globalFlags.usesRealValues) {
        logScores = ErasureUtils.<RVFClassifier<String,String>>uncheckedCast(cl).scoresOf((RVFDatum<String,String>)d);
      } else {
        logScores = cl.scoresOf(d);
      }
      Distribution<String> dist = Distribution.distributionFromLogisticCounter(logScores);
      String answer = null;
      if (globalFlags.biasedHyperplane != null) {
        // System.err.println("Biased using counter: " +
        //         globalFlags.biasedHyperplane);
        List<String> biggestKeys = new ArrayList<String>(logScores.keySet());
        Collections.sort(biggestKeys, Counters.toComparatorDescending(logScores));
        for (String key : biggestKeys) {
          double prob = dist.probabilityOf(key);
          double threshold = globalFlags.biasedHyperplane.getCount(key);
          // System.err.println("  Trying " + key + " prob is " + prob +
          //           " threshold is " + threshold);
          if (prob > threshold) {
            answer = key;
            break;
          }
        }
      }
      if (answer == null) {
        if (globalFlags.usesRealValues) {
          answer = ErasureUtils.<RVFClassifier<String,String>>uncheckedCast(cl).classOf((RVFDatum<String,String>) d);
        } else {
          answer = cl.classOf(d);
        }
      }
      double sim = 0.0;
      if (globalFlags.rankingScoreColumn >= 0) {
        try {
          sim = Double.parseDouble(simpleLineInfo[globalFlags.rankingScoreColumn]);
        } catch (NumberFormatException nfe) {
          // just don't print it
        }
      }
      writeAnswer(simpleLineInfo, answer, dist, contingency, cl, sim);
    } // end for test example

    if (globalFlags.groupingColumn >= 0 && globalFlags.rankingAccuracyClass != null)
      finishRanking(contingency, bestSim);

    if (globalFlags.printFeatures != null) {
      closeFeaturePrinter();
    }
    return writeResultsSummary(test.size(), contingency, cl.labels());
  }


