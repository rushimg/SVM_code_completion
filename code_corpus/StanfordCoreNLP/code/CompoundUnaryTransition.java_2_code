  public boolean isLegal(State state, List<ParserConstraint> constraints) {
    if (state.finished) {
      return false;
    }
    if (state.stack.size() == 0) {
      return false;
    }
    final Tree top = state.stack.peek();
    if (top.children().length == 1 && !top.isPreTerminal()) {
      // Disallow unary transitions after we've already had a unary transition
      return false;
    }
    if (top.label().value().equals(labels[0])) {
      // Disallow unary transitions where the final label doesn't change
      return false;
    }
    // TODO: need to think more about when a unary transition is
    // allowed if the top of the stack is temporary
    if (top.label().value().startsWith("@") && !labels[labels.length - 1].equals(top.label().value().substring(1))) {
      // Disallow a transition if the top is a binarized node and the
      // bottom of the unary transition chain isn't the same type
      return false;
    }
    if (isRoot && (state.stack.size() > 1 || !state.endOfQueue())) {
      return false;
    }

    // Now we check the constraints...
    // Constraints only apply to CompoundUnaryTransitions if the tree
    // is exactly the right size and the tree has not already been
    // constructed to match the constraint.  In that case, we check to
    // see if the candidate transition contains the desired label.
    if (constraints == null) {
      return true;
    }

    for (ParserConstraint constraint : constraints) {
      if (ShiftReduceUtils.leftIndex(top) != constraint.start || ShiftReduceUtils.rightIndex(top) != constraint.end - 1) {
        continue;
      }
      if (constraint.state.matcher(top.value()).matches()) {
        continue;
      }
      boolean found = false;
      for (String label : labels) {
        if (constraint.state.matcher(label).matches()) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }

    return true;
  } 

