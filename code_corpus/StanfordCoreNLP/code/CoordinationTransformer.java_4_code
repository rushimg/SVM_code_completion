  public Tree SQflatten(Tree t) {
    if (headFinder != null && (headFinder instanceof CopulaHeadFinder)) {
      if (((CopulaHeadFinder) headFinder).makesCopulaHead()) {
        return t;
      }
    }
    if (t == null) {
      return null;
    }
    return Tsurgeon.processPattern(flattenSQTregex, flattenSQTsurgeon, t);
  }

  private static TregexPattern removeXOverXTregex = 
    TregexPattern.compile("__=repeat <: (~repeat < __)");

  private static TsurgeonPattern removeXOverXTsurgeon = Tsurgeon.parseOperation("excise repeat repeat");

  public static Tree removeXOverX(Tree t) {
    return Tsurgeon.processPattern(removeXOverXTregex, removeXOverXTsurgeon, t);    
  }

  // UCP (JJ ...) -> ADJP
  // UCP (DT JJ ...) -> ADJP
  // UCP (... (ADJP (JJR older|younger))) -> ADJP
  // UCP (N ...) -> NP
  // UCP ADVP -> ADVP
  // Might want to look for ways to include RB for flatter structures,
  // but then we have to watch out for (RB not) for example
  // Note that the order of OR expressions means the older|younger
  // pattern takes precedence
  // By searching for everything at once, then using one tsurgeon
  // which fixes everything at once, we can save quite a bit of time
  private static final TregexPattern ucpRenameTregex = 
    TregexPattern.compile("/^UCP/=ucp [ <, /^JJ|ADJP/=adjp | ( <1 DT <2 /^JJ|ADJP/=adjp ) |" + 
                          " <- (ADJP=adjp < (JJR < /^(?i:younger|older)$/)) |" + 
                          " <, /^N/=np | ( <1 DT <2 /^N/=np ) | " +
                          " <, /^ADVP/=advp ]");

  // TODO: this turns UCP-TMP into ADVP instead of ADVP-TMP.  What do we actually want?
  private static final TsurgeonPattern ucpRenameTsurgeon =

