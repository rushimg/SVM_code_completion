  private void addMatch(TreeFromFile match, List<Tree> matchedParts) {
    JPanel treeDisplay = new JPanel(new BorderLayout());
    JTextField filename = new JTextField("From file: " + match.getFilename());
    filename.setEditable(false);
    MouseInputAdapter listener = new FilenameMouseInputAdapter(filename);
    filename.addMouseListener(listener);
    filename.addMouseMotionListener(listener);
    treeDisplay.add(filename, BorderLayout.NORTH);
    if(TregexGUI.getInstance().isTdiffEnabled()) {
      tjp = getTreeJPanel(match.getDiffDecoratedTree(), matchedParts);
      tjp.setDiffConstituents(match.getDiffConstituents());
    } else {
      tjp = getTreeJPanel(match.getTree(), matchedParts);
    }

    matchedPartCoordinates = tjp.getMatchedPartCoordinates();
    matchedPartCoordinateIdx = -1;

    treeDisplay.add(tjp, BorderLayout.CENTER);

    filename.setOpaque(true);
    filename.setBackground(tjp.getBackground());
    filename.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));

    scroller.setViewportView(treeDisplay);

    this.revalidate();
    this.repaint();
  }

  void showPrevMatchedPart() {
    if (matchedPartCoordinates.size() == 0)
      return;
    else if (matchedPartCoordinateIdx <= 0)
      matchedPartCoordinateIdx = matchedPartCoordinates.size();

    matchedPartCoordinateIdx--;
    showMatchedPart(matchedPartCoordinateIdx);
  }

  void showNextMatchedPart() {
    if (matchedPartCoordinates.size() == 0)
      return;

    matchedPartCoordinateIdx =
      ++matchedPartCoordinateIdx % matchedPartCoordinates.size();
    showMatchedPart(matchedPartCoordinateIdx);
  }

  private void showMatchedPart(int idx) {
    Point2D.Double coord = matchedPartCoordinates.get(idx);
    Dimension treeSize = tjp.getPreferredSize();

    JScrollBar horizontal = scroller.getHorizontalScrollBar();
    JScrollBar vertical = scroller.getVerticalScrollBar();

    int horizontalLength = horizontal.getMaximum() - horizontal.getMinimum();
    double x = Math.max(0,
                         - (scroller.getWidth() / 2.0)));

    int verticalLength = vertical.getMaximum() - vertical.getMinimum();
    double y = Math.max(0,
                         - (scroller.getHeight() / 2.0)));

    horizontal.setValue((int) x);
    vertical.setValue((int) y);
  }

  private void doExportTree() {
    JFileChooser chooser = new JFileChooser();
    chooser.setSelectedFile(new File("./tree.png"));
    FileNameExtensionFilter filter = new FileNameExtensionFilter("PNG images", "png");
    chooser.setFileFilter(filter);

    int status = chooser.showSaveDialog(this);

    if (status != JFileChooser.APPROVE_OPTION)
      return;

    Dimension size = tjp.getPreferredSize();
    BufferedImage im = new BufferedImage((int) size.getWidth(),
                                         (int) size.getHeight(),
                                         BufferedImage.TYPE_INT_ARGB);
    Graphics2D g = im.createGraphics();
    tjp.paint(g);

    try {
      ImageIO.write(im, "png", chooser.getSelectedFile());
    } catch (IOException e) {
      JOptionPane.showMessageDialog(this, "Failed to save the tree image file.\n"
                                    + e.getLocalizedMessage(), "Export Error",
                                    JOptionPane.ERROR_MESSAGE);
    }
  }


  private ScrollableTreeJPanel getTreeJPanel(Tree t, List<Tree> matchedParts) {
    final ScrollableTreeJPanel treeJP = new ScrollableTreeJPanel(SwingConstants.CENTER,SwingConstants.TOP);
    treeJP.setFontName(fontName);
    treeJP.setFontSize(fontSize);
    treeJP.setDefaultColor(defaultColor);
    treeJP.setMatchedColor(matchedColor);
    treeJP.setTree(t);
    treeJP.setMatchedParts(matchedParts);
    treeJP.setBackground(Color.WHITE);
    treeJP.setFocusable(true);

    final JPopupMenu treePopup = new JPopupMenu();

    JMenuItem copy = new JMenuItem("Copy");
    copy.setActionCommand((String) TransferHandler.getCopyAction()
                          .getValue(Action.NAME));
    copy.addActionListener(new TregexGUI.TransferActionListener());
    int mask = TregexGUI.isMacOSX() ? InputEvent.META_MASK : InputEvent.CTRL_MASK;
    copy.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, mask));
    treePopup.add(copy);

    JMenuItem exportTree = new JMenuItem("Export tree as image");
    exportTree.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
          doExportTree();
        }
      });
    treePopup.add(exportTree);

    treeJP.addMouseListener(new MouseAdapter() {
        @Override
        public void mouseClicked(MouseEvent e) {
          treeJP.requestFocusInWindow();
        }

        private void maybeShowPopup(MouseEvent e) {
          if (e.isPopupTrigger())
            treePopup.show(e.getComponent(), e.getX(), e.getY());
        }

        @Override
        public void mousePressed(MouseEvent e) {
          maybeShowPopup(e);
        }

        @Override
        public void mouseReleased(MouseEvent e) {
          maybeShowPopup(e);
        }
      });

    DisplayMouseMotionAdapter d = new DisplayMouseMotionAdapter();
    treeJP.addMouseMotionListener(d);
    treeJP.addMouseListener(d);
    treeJP.setTransferHandler(new DisplayTransferHandler());
    InputMap imap = treeJP.getInputMap();
    imap.put(KeyStroke.getKeyStroke("ctrl C"),
        TransferHandler.getCopyAction().getValue(Action.NAME));
    ActionMap map = treeJP.getActionMap();
    map.put(TransferHandler.getCopyAction().getValue(Action.NAME),
        TransferHandler.getCopyAction());
    return treeJP;
  }

  
  private static class DisplayMouseMotionAdapter extends MouseInputAdapter {
