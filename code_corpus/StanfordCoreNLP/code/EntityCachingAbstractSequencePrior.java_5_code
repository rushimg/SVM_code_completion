  public int[] otherOccurrences(Entity entity){
    List<Integer> other = new ArrayList<Integer>();
    for (int i = 0; i < doc.size(); i++) {
      if (i == entity.startPosition) { continue; }
      if (matches(entity, i)) {
        other.add(Integer.valueOf(i));
      }
    }
    return toArray(other);
  }

  public static int[] toArray(List<Integer> list) {
    int[] arr = new int[list.size()];
    for (int i = 0; i < arr.length; i++) {
      arr[i] = list.get(i);
    }
    return arr;
  }

  public boolean matches(Entity entity, int position) {
  	String word = doc.get(position).get(CoreAnnotations.TextAnnotation.class);
    if (word.equalsIgnoreCase(entity.words.get(0))) {
      //boolean matches = true;
      for (int j = 1; j < entity.words.size(); j++) {
        if (position + j >= doc.size()) {
          return false;
        }
        String nextWord = doc.get(position+j).get(CoreAnnotations.TextAnnotation.class);
        if (!nextWord.equalsIgnoreCase(entity.words.get(j))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }


  public boolean joiningTwoEntities(int[] sequence, int position) {
    if (sequence[position] == backgroundSymbol) { return false; }
    if (position > 0 && position < sequence.length - 1) {
      return (sequence[position] == sequence[position - 1] &&
              sequence[position] == sequence[position + 1]);
    }
    return false;
  }

  public boolean splittingTwoEntities(int[] sequence, int position) {
    if (position > 0 && position < sequence.length - 1) {
      return (entities[position - 1] == entities[position + 1] &&
              entities[position - 1] != null);
    }
    return false;
  }

  public boolean appendingEntity(int[] sequence, int position) {
    if (position > 0) {
      if (entities[position - 1] == null) { return false; }
      Entity prev = entities[position - 1];
      return (sequence[position] == sequence[position - 1] &&
              prev.startPosition + prev.words.size() == position);
    }
    return false;
  }

  public boolean prependingEntity(int[] sequence, int position) {
    if (position < sequence.length - 1) {
      if (entities[position + 1] == null) { return false; }
      return (sequence[position] == sequence[position + 1]);
    }
    return false;
  }

  public boolean addingSingletonEntity(int[] sequence, int position) {
    if (sequence[position] == backgroundSymbol) { return false; }
    if (position > 0) {
      if (sequence[position - 1] == sequence[position]) { return false; }
    }
    if (position < sequence.length - 1) {
      if (sequence[position + 1] == sequence[position]) { return false; }
    }
    return true;
  }

  public boolean removingEndOfEntity(int[] sequence, int position) {
    if (position > 0) {
      if (sequence[position - 1] == backgroundSymbol) { return false; }
      Entity prev = entities[position - 1];
      if (prev != null) {
        return (prev.startPosition + prev.words.size() > position);
      }
    }
    return false;
  }

  public boolean removingBeginningOfEntity(int[] sequence, int position) {
    if (position < sequence.length - 1) {
      if (sequence[position + 1] == backgroundSymbol) { return false; }
      Entity next = entities[position + 1];
      if (next != null) {
        return (next.startPosition <= position);
      }
    }
    return false;
  }

  public boolean noChange(int[] sequence, int position) {
    if (position > 0) {
      if (sequence[position - 1] == sequence[position]) {
        return entities[position - 1] == entities[position];
      }
    }
    if (position < sequence.length - 1) {
      if (sequence[position + 1] == sequence[position]) {
        return entities[position] == entities[position + 1];
      }
    }
    // actually, can't tell.  either no change, or singleton
    // changed type
    return false;
  }

  public void updateSequenceElement(int[] sequence, int position, int oldVal) {
    if (VERBOSE) System.out.println("changing position "+position+" from " +classIndex.get(oldVal)+" to "+classIndex.get(sequence[position]));

    this.sequence = sequence;

    // no change?
    if (noChange(sequence, position)) {
      if (VERBOSE) System.out.println("no change");
      if (VERBOSE) System.out.println(this);
      return;
    }
    // are we joining 2 entities?
    else if (joiningTwoEntities(sequence, position)) {
      if (VERBOSE) System.out.println("joining 2 entities");
      Entity newEntity = new Entity();
      Entity prev = entities[position - 1];
      Entity next = entities[position + 1];
      newEntity.startPosition = prev.startPosition;
      newEntity.words = new ArrayList<String>();
      newEntity.words.addAll(prev.words);
      String word = doc.get(position).get(CoreAnnotations.TextAnnotation.class);
      newEntity.words.add(word);
      newEntity.words.addAll(next.words);
      newEntity.type = sequence[position];
      List<Integer> other = new ArrayList<Integer>();
      for (int i = 0; i < prev.otherOccurrences.length; i++) {
        int pos = prev.otherOccurrences[i];
        if (matches(newEntity, pos)) {
          other.add(Integer.valueOf(pos));
        }
      }
      newEntity.otherOccurrences = toArray(other);
      addEntityToEntitiesArray(newEntity);
      if (VERBOSE) System.out.println(this);
      return;
    }
    // are we splitting up an entity?
    else if (splittingTwoEntities(sequence, position)) {
      if (VERBOSE) System.out.println("splitting into 2 entities");
      Entity entity = entities[position];
      Entity prev = new Entity();
      prev.type = entity.type;
      prev.startPosition = entity.startPosition;
      prev.words = new ArrayList<String>(entity.words.subList(0, position - entity.startPosition));
      prev.otherOccurrences = otherOccurrences(prev);
      addEntityToEntitiesArray(prev);
      Entity next = new Entity();
      next.type = entity.type;
      next.startPosition = position + 1;
      next.words = new ArrayList<String>(entity.words.subList(position - entity.startPosition + 1, entity.words.size()));
      next.otherOccurrences = otherOccurrences(next);
      addEntityToEntitiesArray(next);
      if (sequence[position] == backgroundSymbol) {
        entities[position] = null;
      } else {
        Entity newEntity = new Entity();
        newEntity.startPosition = position;
        newEntity.type = sequence[position];
        newEntity.words = new ArrayList<String>();
        String word = doc.get(position).get(CoreAnnotations.TextAnnotation.class);
        newEntity.words.add(word);
        newEntity.otherOccurrences = otherOccurrences(newEntity);
        entities[position] = newEntity;
      }
      if (VERBOSE) System.out.println(this);
      return;
    }
    // are we prepending to an entity ?
    else if (prependingEntity(sequence, position)) {
      if (VERBOSE) System.out.println("prepending entity");
      Entity newEntity = new Entity();
      Entity next = entities[position + 1];
      newEntity.startPosition = position;
      newEntity.words = new ArrayList<String>();
      String word = doc.get(position).get(CoreAnnotations.TextAnnotation.class);
      newEntity.words.add(word);
      newEntity.words.addAll(next.words);
      newEntity.type = sequence[position];
      //List<Integer> other = new ArrayList<Integer>();
      newEntity.otherOccurrences = otherOccurrences(newEntity);
      addEntityToEntitiesArray(newEntity);

      if (removingEndOfEntity(sequence, position)) {
        if (VERBOSE) System.out.println(" ... and removing end of previous entity.");
        Entity prev = entities[position - 1];
        prev.words.remove(prev.words.size()-1);
        prev.otherOccurrences = otherOccurrences(prev);
      }
      if (VERBOSE) System.out.println(this);
      return;
    }
    // are we appending to an entity ?
    else if (appendingEntity(sequence, position)) {
      if (VERBOSE) System.out.println("appending entity");
      Entity newEntity = new Entity();
      Entity prev = entities[position - 1];
      newEntity.startPosition = prev.startPosition;
      newEntity.words = new ArrayList<String>();
      newEntity.words.addAll(prev.words);
      String word = doc.get(position).get(CoreAnnotations.TextAnnotation.class);
      newEntity.words.add(word);
      newEntity.type = sequence[position];
      List<Integer> other = new ArrayList<Integer>();
      for (int i = 0; i < prev.otherOccurrences.length; i++) {
        int pos = prev.otherOccurrences[i];
        if (matches(newEntity, pos)) {
          other.add(Integer.valueOf(pos));
        }
      }
      newEntity.otherOccurrences = toArray(other);
      addEntityToEntitiesArray(newEntity);

      if (removingBeginningOfEntity(sequence, position)) {
        if (VERBOSE) System.out.println(" ... and removing beginning of next entity.");
        entities[position + 1].words.remove(0);
        entities[position + 1].startPosition++;
      }
      if (VERBOSE) System.out.println(this);
      return;
    }
    // adding new singleton entity
    else if (addingSingletonEntity(sequence, position)) {
      Entity newEntity = new Entity();
      if (VERBOSE) System.out.println("adding singleton entity");
      newEntity.startPosition = position;
      newEntity.words = new ArrayList<String>();
      String word = doc.get(position).get(CoreAnnotations.TextAnnotation.class);
      newEntity.words.add(word);
      newEntity.type = sequence[position];
      newEntity.otherOccurrences = otherOccurrences(newEntity);
      addEntityToEntitiesArray(newEntity);

      if (removingEndOfEntity(sequence, position)) {
        if (VERBOSE) System.out.println(" ... and removing end of previous entity.");
        Entity prev = entities[position - 1];
        prev.words.remove(prev.words.size()-1);
        prev.otherOccurrences = otherOccurrences(prev);
      }

      if (removingBeginningOfEntity(sequence, position)) {
        if (VERBOSE) System.out.println(" ... and removing beginning of next entity.");
        entities[position + 1].words.remove(0);
        entities[position + 1].startPosition++;
      }

      if (VERBOSE) System.out.println(this);
      return;
    }
    // are splitting off the prev entity?
    else if (removingEndOfEntity(sequence, position)) {
      if (VERBOSE) System.out.println("splitting off prev entity");
      Entity prev = entities[position - 1];
      prev.words.remove(prev.words.size() - 1);
      prev.otherOccurrences = otherOccurrences(prev);
      entities[position] = null;
    }
    // are we splitting off the next entity?
    else if (removingBeginningOfEntity(sequence, position)) {
      if (VERBOSE) System.out.println("splitting off next entity");
      Entity next = entities[position + 1];
      next.words.remove(0);
      next.startPosition++;
      next.otherOccurrences = otherOccurrences(next);
      entities[position] = null;
    } else {
      entities[position] = null;
    }
    if (VERBOSE) System.out.println(this);
  }

  @Override
  public String toString() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < entities.length; i++) {
      sb.append(i);
      sb.append("\t");
      String word = doc.get(i).get(CoreAnnotations.TextAnnotation.class);
      sb.append(word);
      sb.append("\t");
      sb.append(classIndex.get(sequence[i]));
      if (entities[i] != null) {
        sb.append("\t");
        sb.append(entities[i].toString(classIndex));
      }
      sb.append("\n");
    }
    return sb.toString();
  }

  public String toString(int pos) {
    StringBuffer sb = new StringBuffer();
    for (int i = Math.max(0, pos - 10); i < Math.min(entities.length, pos + 10); i++) {
      sb.append(i);
      sb.append("\t");
      String word = doc.get(i).get(CoreAnnotations.TextAnnotation.class);
      sb.append(word);
      sb.append("\t");
      sb.append(classIndex.get(sequence[i]));
      if (entities[i] != null) {
        sb.append("\t");
        sb.append(entities[i].toString(classIndex));
      }
      sb.append("\n");
    }
    return sb.toString();
  }
}

class Entity {
  public int startPosition;
  public List<String> words;
  public int type;

