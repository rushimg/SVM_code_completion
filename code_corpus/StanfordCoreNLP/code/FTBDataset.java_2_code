  private String getCanditoTreeID(Tree t) {
    String canditoName = null;
    if (t.label() instanceof CoreLabel) {
      String fileName = ((CoreLabel) t.label()).docID();
      fileName = fileName.substring(0, fileName.lastIndexOf('.'));
      String ftbID = ((CoreLabel) t.label()).get(CoreAnnotations.SentenceIDAnnotation.class);
      if (fileName != null && ftbID != null) {
        canditoName = fileName + "-" + ftbID;
      } else {
        throw new NullPointerException("fileName " + fileName + ", ftbID " + ftbID);
      }
    } else {
      throw new IllegalArgumentException("Trees constructed without CoreLabels! Can't extract metadata!");
    }
    return canditoName;
  }

  @Override
  public void build() {
    for(File path : pathsToData) {
      treebank.loadPath(path,treeFileExtension,false);
    }

    PrintWriter outfile = null;
    PrintWriter flatFile = null;
    try {
      outfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFileName),"UTF-8")));
      flatFile = (makeFlatFile) ? new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(flatFileName),"UTF-8"))) : null;

      outputFileList.add(outFileName);

      if(makeFlatFile) {
        outputFileList.add(flatFileName);
        toStringBuffer.append(" Made flat files\n");
      }

      preprocessMWEs();

      List<TregexPattern> badTrees = new ArrayList<TregexPattern>();
      //These trees appear in the Candito training set
      //They are mangled by the TreeCorrector, so discard them ahead of time.
      badTrees.add(TregexPattern.compile("@SENT <: @PUNC"));
      badTrees.add(TregexPattern.compile("@SENT <1 @PUNC <2 @PUNC !<3 __"));

      //wsg2011: This filters out tree #552 in the Candito test set. We saved this tree for the
      //EMNLP2011 paper, but since it consists entirely of punctuation, it won't be evaluated anyway.
      //Since we aren't doing the split in this data set, just remove the tree.
      badTrees.add(TregexPattern.compile("@SENT <1 @PUNC <2 @PUNC <3 @PUNC <4 @PUNC !<5 __"));

      for(Tree t : treebank) {
        //Filter out bad trees
        boolean skipTree = false;
        for(TregexPattern p : badTrees) {
          skipTree = p.matcher(t).find();
          if(skipTree) break;
        }
        if(skipTree) {
          System.err.println("Discarding tree: " + t.toString());
          continue;
        }

        // Filter out trees that aren't in this part of the split
        if (splitSet != null) {
          String canditoTreeID = getCanditoTreeID(t);
          if ( ! splitSet.contains(canditoTreeID)) {
            continue;
          }
        }

        if(customTreeVisitor != null)
          customTreeVisitor.visitTree(t);

        // outfile.printf("%s\t%s%n",treeName,t.toString());
        outfile.println(t.toString());

        if(makeFlatFile) {
          String flatString = (removeEscapeTokens) ?
              ATBTreeUtils.unEscape(ATBTreeUtils.flattenTree(t)) : ATBTreeUtils.flattenTree(t);
              flatFile.println(flatString);
        }
      }

    } catch (UnsupportedEncodingException e) {
      System.err.printf("%s: Filesystem does not support UTF-8 output%n", this.getClass().getName());
      e.printStackTrace();

    } catch (FileNotFoundException e) {
      System.err.printf("%s: Could not open %s for writing%n", this.getClass().getName(), outFileName);

    } catch (TregexParseException e) {
      System.err.printf("%s: Could not compile Tregex expressions%n", this.getClass().getName());
      e.printStackTrace();

    } finally {
      if(outfile != null)
        outfile.close();
      if(flatFile != null)
        flatFile.close();
    }
  }

