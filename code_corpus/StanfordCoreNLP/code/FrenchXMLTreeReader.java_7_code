  private List<String> getWordString(String text) {
    List<String> toks = new ArrayList<String>();
    if(text == null || text.equals(""))
      toks.add(EMPTY_LEAF);
    else {
      //Strip spurious parens
      if(text.length() > 1)
        text = text.replaceAll("[\\(\\)]", "");

      //Check for numbers and punctuation
      String noWhitespaceStr = text.replaceAll("\\s+", "");
      if(noWhitespaceStr.matches("\\d+") || noWhitespaceStr.matches("\\p{Punct}+"))
        toks.add(noWhitespaceStr);
      else
        toks = Arrays.asList(text.split("\\s+"));
    }

    if(toks.size() == 0)
      throw new RuntimeException(this.getClass().getName() + ": Zero length token list for: " + text);

    return toks;
  }

  private Tree getTreeFromXML(Node root) {
    final Element eRoot = (Element) root;

    if (eRoot.getNodeName().equals(NODE_WORD) &&
        eRoot.getElementsByTagName(NODE_WORD).getLength() == 0) {
      String posStr = getPOS(eRoot);
      posStr = treeNormalizer.normalizeNonterminal(posStr);

      List<String> lemmas = getLemma(eRoot);
      String morph = getMorph(eRoot);
      List<String> leafToks = getWordString(eRoot.getTextContent().trim());
      String subcat = getSubcat(eRoot);
      
      if (lemmas != null && lemmas.size() != leafToks.size()) {
        // If this happens (and it does for a few poorly editted trees)
        // we assume something has gone wrong and ignore the lemmas.
        System.err.println("Lemmas don't match tokens, ignoring lemmas: " +
                           "lemmas " + lemmas + ", tokens " + leafToks);
        lemmas = null;
      }

      //Terminals can have multiple tokens (MWEs). Make these into a
      //flat structure for now.
      Tree t = null;
      List<Tree> kids = new ArrayList<Tree>();
      if(leafToks.size() > 1) {
        for (int i = 0; i < leafToks.size(); ++i) {
          String tok = leafToks.get(i);
          String s = treeNormalizer.normalizeTerminal(tok);
          List<Tree> leafList = new ArrayList<Tree>();
          Tree leafNode = treeFactory.newLeaf(s);
          if(leafNode.label() instanceof HasWord)
            ((HasWord) leafNode.label()).setWord(s);
          if (leafNode.label() instanceof CoreLabel && lemmas != null) {
            ((CoreLabel) leafNode.label()).setLemma(lemmas.get(i));
          }
          if(leafNode.label() instanceof HasContext) {
            ((HasContext) leafNode.label()).setOriginalText(morph);
          }
          if (leafNode.label() instanceof HasCategory) {
            ((HasCategory) leafNode.label()).setCategory(subcat);
          }
          leafList.add(leafNode);

          Tree posNode = treeFactory.newTreeNode(MISSING_POS, leafList);
          if(posNode.label() instanceof HasTag)
            ((HasTag) posNode.label()).setTag(MISSING_POS);

          kids.add(posNode);
        }
        t = treeFactory.newTreeNode(MISSING_PHRASAL, kids);

      } else {
        String leafStr = treeNormalizer.normalizeTerminal(leafToks.get(0));
        Tree leafNode = treeFactory.newLeaf(leafStr);
        if (leafNode.label() instanceof HasWord)
          ((HasWord) leafNode.label()).setWord(leafStr);
        if (leafNode.label() instanceof CoreLabel && lemmas != null) {
          ((CoreLabel) leafNode.label()).setLemma(lemmas.get(0));
        }
        if (leafNode.label() instanceof HasContext) {
          ((HasContext) leafNode.label()).setOriginalText(morph);
        }
        if (leafNode.label() instanceof HasCategory) {
          ((HasCategory) leafNode.label()).setCategory(subcat);
        }
        kids.add(leafNode);

        t = treeFactory.newTreeNode(posStr, kids);
        if (t.label() instanceof HasTag) ((HasTag) t.label()).setTag(posStr);
      }

      return t;
    }

    List<Tree> kids = new ArrayList<Tree>();
    for(Node childNode = eRoot.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
      if(childNode.getNodeType() != Node.ELEMENT_NODE) continue;
      Tree t = getTreeFromXML(childNode);
      if(t == null) {
        System.err.printf("%s: Discarding empty tree (root: %s)%n", this.getClass().getName(),childNode.getNodeName());
      } else {
        kids.add(t);
      }
    }

    // MWEs have a label with a
    String rootLabel = eRoot.getNodeName().trim();
    boolean isMWE = rootLabel.equals("w") && eRoot.hasAttribute(ATTR_POS);
    if(isMWE)
      rootLabel = eRoot.getAttribute(ATTR_POS).trim();

    Tree t = (kids.size() == 0) ? null : treeFactory.newTreeNode(treeNormalizer.normalizeNonterminal(rootLabel), kids);

    if(t != null && isMWE)
      t = postProcessMWE(t);

    return t;
  }


  private Tree postProcessMWE(Tree t) {
    String tYield = Sentence.listToString(t.yield()).replaceAll("\\s+", "");
      List<Tree> kids = new ArrayList<Tree>();
      kids.add(treeFactory.newLeaf(tYield));
      t = treeFactory.newTreeNode(t.value(), kids);
    } else {
      t.setValue(MWE_PHRASAL + t.value());
    }
    return t;
  }


