    private static final long serialVersionUID = 5628505169749516972L;

    @Override
    public double incrementCount(K o, double count) {
      throw new UnsupportedOperationException();
    }

    @Override
    public void setCount(K o, double count) {
      throw new UnsupportedOperationException();
    }

    @Override
    public double totalCount() {
      return GeneralizedCounter.this.totalCount();
    }

    @Override
    public double getCount(Object o) {
      return GeneralizedCounter.this.getCount(o);
    }

    @Override
    public int size() {
      return GeneralizedCounter.this.map.size();
    }

    @Override
    public Set<K> keySet() {
      return ErasureUtils.<Set<K>>uncheckedCast(GeneralizedCounter.this.keySet(Generics.newHashSet(), zeroKey, false));
    }

    @Override
    public double remove(Object o) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean containsKey(Object key) {
      return GeneralizedCounter.this.map.containsKey(key);
    }

    @Override
    public void clear() {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean isEmpty() {
      return GeneralizedCounter.this.isEmpty();
    }

    @Override
    public Set<Map.Entry<K, Double>> entrySet() {
      return ErasureUtils.<Set<Map.Entry<K, Double>>>uncheckedCast(GeneralizedCounter.this.entrySet(new HashSet<Map.Entry<Object, Double>>(), zeroKey, false));
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      //return false;
      if (!(o instanceof ClassicCounter)) {
        return false;
      } else {
        // System.out.println("it's a counter!");
        // Set e = entrySet();
        // Set e1 = ((Counter) o).map.entrySet();
        // System.out.println(e + "\n" + e1);
        return entrySet().equals(((ClassicCounter<?>) o).entrySet());
      }
    }

    @Override
    public int hashCode() {
      int total = 17;
      for (Object o: entrySet()) {
      }
      return total;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("{");
      for (Iterator<Map.Entry<K, Double>> i = entrySet().iterator(); i.hasNext();) {
        Map.Entry<K, Double> e = i.next();
        sb.append(e.toString());
        if (i.hasNext()) {
          sb.append(",");
        }
      }
      sb.append("}");
      return sb.toString();
    }

  } // end class OneDimensionalCounterView


  @Override
  public String toString() {
    return map.toString();
  }

  public String toString(String param) {
    if (param.equals("contingency")) {
      StringBuilder sb = new StringBuilder();
      for (K obj: ErasureUtils.sortedIfPossible(topLevelKeySet())) {
        sb.append(obj);
        sb.append(" = ");
        GeneralizedCounter<K> gc = conditionalizeOnce(obj);
        sb.append(gc);
        sb.append("\n");
      }
      return sb.toString();
    } else if (param.equals("sorted")) {
      StringBuilder sb = new StringBuilder();
      sb.append("{\n");
      for (K obj: ErasureUtils.sortedIfPossible(topLevelKeySet())) {
        sb.append(obj);
        sb.append(" = ");
        GeneralizedCounter<K> gc = conditionalizeOnce(obj);
        sb.append(gc);
        sb.append("\n");
      }
      sb.append("}\n");
      return sb.toString();
    } else {
      return toString();
    }
  }


