  public static <V1,V2,V3> Iterable<Triple<V1,V2,V3>> merge(
      final Iterable<V1> iter1, final Iterable<V2> iter2, final Iterable<V3> iter3,
      final IncrementComparator<V1,V2> comparatorA,
      final IncrementComparator<V1,V3> comparatorB) {

    // partial merge on first two iterables
    Iterable<Pair<V1,V2>> partial = merge(iter1, iter2, comparatorA);

    IncrementComparator<Pair<V1,V2>,V3> inc =
      new IncrementComparator<Pair<V1,V2>,V3>() {
      public int compare(Pair<V1, V2> a, V3 b) {
        return comparatorB.compare(a.first, b);
      }
    };

    // flattens the pairs into triple
    Function<Pair<Pair<V1,V2>, V3>, Triple<V1,V2,V3>> flatten =
      new Function<Pair<Pair<V1,V2>,V3>, Triple<V1,V2,V3>>() {
      public Triple<V1, V2, V3> apply(Pair<Pair<V1, V2>, V3> in) {
        return new Triple<V1,V2,V3>(in.first.first,in.first.second,in.second);
      }
    };

    return transform(merge(partial, iter3, inc), flatten);
  }

