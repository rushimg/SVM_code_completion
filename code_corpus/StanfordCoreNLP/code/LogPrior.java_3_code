  public LogPrior(double[] C) {
    this.type = LogPriorType.MULTIPLE_QUADRATIC;
    double[] sigmaSqM = new double[C.length];
    for (int i=0;i<C.length;i++){
      sigmaSqM[i] = 1./C[i];
    }
    this.sigmaSqM = sigmaSqM;
    setSigmaSquaredM(sigmaSqM);
//    this.regularizationHyperparameters = regularizationHyperparameters;
  }

  
//  private double sigma;
  private double sigmaSq;
  private double sigmaQu;
  private double epsilon;

  public double getSigma() {
    if (type == LogPriorType.ADAPT) {
      return otherPrior.getSigma();
    } else {
      return Math.sqrt(sigmaSq);
    }
  }

  public double getSigmaSquared() {
    if (type == LogPriorType.ADAPT) {
      return otherPrior.getSigmaSquared();
    } else {
      return sigmaSq;
    }
  }

  public double[] getSigmaSquaredM() {
    if (type == LogPriorType.MULTIPLE_QUADRATIC) {
      return sigmaSqM;
    } else {
      throw new RuntimeException("LogPrior.getSigmaSquaredM is undefined for any prior but MULTIPLE_QUADRATIC" + this);
    }
  }  
  
  
  public double getEpsilon() {
    if (type == LogPriorType.ADAPT) {
      return otherPrior.getEpsilon();
    } else {
      return epsilon;
    }
  }

  public void setSigma(double sigma) {
    if (type == LogPriorType.ADAPT) { otherPrior.setSigma(sigma); }
    else {
//    this.sigma = sigma;
    }
  }

//  public void setSigmaM(double[] sigmaM) {
//    if (type == LogPriorType.MULTIPLE_QUADRATIC) {
//      //    this.sigma = Math.sqrt(sigmaSq);
//      double[] sigmaSqM = new double[sigmaM.length];
//      double[] sigmaQuM = new double[sigmaM.length];
//      
//      for (int i = 0;i<sigmaM.length;i++){
//      }      
//      this.sigmaSqM = sigmaSqM;
//      
//      for (int i = 0;i<sigmaSqM.length;i++){
//      }
//      this.sigmaQuM = sigmaQuM;
//      
//    } else {
//      throw new RuntimeException("LogPrior.getSigmaSquaredM is undefined for any prior but MULTIPLE_QUADRATIC" + this);
//    }      
//  }  
  
  
  public void setSigmaSquared(double sigmaSq) {
    if (type == LogPriorType.ADAPT) { otherPrior.setSigmaSquared(sigmaSq); }
    else {
//    this.sigma = Math.sqrt(sigmaSq);
      this.sigmaSq = sigmaSq;
    }
  }
  
  public void setSigmaSquaredM(double[] sigmaSq) {
    if (type == LogPriorType.ADAPT) { otherPrior.setSigmaSquaredM(sigmaSq); }
    if (type == LogPriorType.MULTIPLE_QUADRATIC) {
      //    this.sigma = Math.sqrt(sigmaSq);
      this.sigmaSqM = sigmaSq.clone();
      double[] sigmaQuM = new double[sigmaSq.length];
      for (int i = 0;i<sigmaSq.length;i++){
      }
      this.sigmaQuM = sigmaQuM;
      
    } else {
      throw new RuntimeException("LogPrior.getSigmaSquaredM is undefined for any prior but MULTIPLE_QUADRATIC" + this);
    }         
  }
    
  public void setEpsilon(double epsilon) {
    if (type == LogPriorType.ADAPT) { otherPrior.setEpsilon(epsilon); }
    else {
      this.epsilon = epsilon;
    }
  }

  public double computeStochastic(double[] x, double[] grad, double fractionOfData) {
    if (type == LogPriorType.ADAPT) {
      double[] newX = ArrayMath.pairwiseSubtract(x, means);
      return otherPrior.computeStochastic(newX, grad, fractionOfData);
    } else if (type == LogPriorType.MULTIPLE_QUADRATIC) {
      
      double[] sigmaSquaredOld = getSigmaSquaredM();
      double[] sigmaSquaredTemp = sigmaSquaredOld.clone(); 
      for (int i = 0; i < x.length; i++) {
        sigmaSquaredTemp[i] /= fractionOfData;
      }
      setSigmaSquaredM(sigmaSquaredTemp);
      
      double val = compute(x, grad);
      setSigmaSquaredM(sigmaSquaredOld);
      return val;
      
    } else {
      double sigmaSquaredOld = getSigmaSquared();
      setSigmaSquared(sigmaSquaredOld / fractionOfData);
      
      double val = compute(x, grad);
      setSigmaSquared(sigmaSquaredOld);
      return val;
    }
  }
  
