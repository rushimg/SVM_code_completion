  protected List<IntPair> findTargetStringOffsetsExct(String text, String targetString, int start, int end)
  {
    if (start > text.length()) return null;
    if (end > text.length()) return null;
    List<IntPair> offsets = null;
    int i = text.indexOf(targetString, start);
    if (i >= 0 && i < end) { offsets = new ArrayList<IntPair>(); }
    while (i >= 0 && i < end) {
      boolean matched = true;
      if (i > 0) {
        char charBefore = text.charAt(i-1);
        if (Character.isLetterOrDigit(charBefore)) {
          matched = false;
        }
      }
      if (i + targetString.length() < text.length()) {
        char charAfter = text.charAt(i+targetString.length());
        if (Character.isLetterOrDigit(charAfter)) {
          matched = false;
        }
      }
      if (matched) {
        offsets.add(new IntPair(i, i+targetString.length()));
        i += targetString.length();
      } else {
        i++;
      }
      i = text.indexOf(targetString, i);
    }
    return offsets;
  }

  private CacheMap<String, Pattern> targetStringPatternCache = new CacheMap<String,Pattern>(5000);

  public final static Comparator<String> LONGEST_STRING_COMPARATOR = new LongestStringComparator();
  public static class LongestStringComparator implements Comparator<String> {
    public int compare(String o1, String o2) {
      int l1 = o1.length();
      int l2 = o2.length();
      if (l1 == l2) {
        return o1.compareTo(o2);
      } else {
        return (l1 > l2)? -1:1;
      }
    }
  }

  public Pattern getPattern(String[] targetStrings) {
    String regex = getRegex(targetStrings);
    return Pattern.compile(regex);
  }

  public String getRegex(String[] targetStrings) {
    List<String> strings = Arrays.asList(targetStrings);
    // Sort by longest string first
    Collections.sort(strings, LONGEST_STRING_COMPARATOR);
    StringBuilder sb = new StringBuilder();
    for (String s:strings) {
      if (sb.length() > 0) {
        sb.append("|");
      }
      sb.append(getRegex(s));
    }
    String regex = sb.toString();
    return regex;
  }

  public Pattern getPattern(String targetString)
  {
    Pattern pattern = targetStringPatternCache.get(targetString);
    if (pattern == null) {
      pattern = createPattern(targetString);
      targetStringPatternCache.put(targetString, pattern);
    }
    return pattern;
  }

  public Pattern createPattern(String targetString)
  {
    String wordRegex = getRegex(targetString);
    return Pattern.compile(wordRegex);
  }

  public String getRegex(String targetString)
  {
    String wordRegex;
    switch (matchType) {
      case EXCT: wordRegex = Pattern.quote(targetString); break;
      case EXCTWS: wordRegex = getExctWsRegex(targetString); break;
      case LWS: wordRegex = getLWsRegex(targetString); break;
      case LNRM: wordRegex = getLnrmRegex(targetString); break;
      case REGEX: wordRegex = targetString;
      default:
        throw new UnsupportedOperationException();
    }
    return wordRegex;
  }

  private static Pattern whitespacePattern = Pattern.compile("\\s+");
  public String getExctWsRegex(String targetString)
  {
    StringBuilder sb = new StringBuilder();
    String[] fields = whitespacePattern.split(targetString);
    for (String field:fields) {
      // require at least one whitespace if there is whitespace in target string
      if (sb.length() > 0) {
        sb.append("\\s+");
      }
      // Allow any number of spaces between punctuation and text
      String tmp = punctWhitespacePattern.matcher(field).replaceAll(" $1 ");
      tmp = tmp.trim();
      String[] punctFields = whitespacePattern.split(tmp);
      for (String f:punctFields) {
        if (sb.length() > 0) {
        }
        sb.append(Pattern.quote(f));
      }
    }
    return sb.toString();
  }

  public String getLWsRegex(String targetString)
  {
    StringBuilder sb = new StringBuilder("(?u)(?i)");
    sb.append(getExctWsRegex(targetString));
    return sb.toString();
  }

  private static final Pattern lnrmDelimPattern = Pattern.compile("(?:\\p{Punct}|\\s)+");
  public String getLnrmRegex(String targetString)
  {
    StringBuilder sb = new StringBuilder("(?u)(?i)");
    String[] fields = lnrmDelimPattern.split(targetString);
    boolean first = true;
    for (String field:fields) {
      if (!first) {
        sb.append(lnrmDelimPatternAny);
      } else {
        first = false;
      }
      sb.append(Pattern.quote(field));
    }
    return sb.toString();
  }

