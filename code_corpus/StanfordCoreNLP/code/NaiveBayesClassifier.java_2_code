  private static final long serialVersionUID = 1544820342684024068L;
  Counter<Pair<Pair<L, F>, Number>> weights; //the keys will be class and feature and value
  Counter<L> priors;
  Set<F> features; // we need all features to add the weights for zero-valued ones
  private boolean addZeroValued; // whether to add features as having value 0 if they are not in Datum/RFVDatum
  Counter<L> priorZero; //if we need to add the zeros, pre-compute the weight for all zeros for each class
  Set<L> labels;
  private final Integer zero = Integer.valueOf(0);

  public Collection<L> labels() {
    return labels;
  }

  public L classOf(RVFDatum<L, F> example) {
    Counter<L> scores = scoresOf(example);
    return Counters.argmax(scores);
  }

  public ClassicCounter<L> scoresOf(RVFDatum<L, F> example) {
    ClassicCounter<L> scores = new ClassicCounter<L>();
    Counters.addInPlace(scores, priors);
    if (addZeroValued) {
      Counters.addInPlace(scores, priorZero);
    }
    for (L l : labels) {
      double score = 0.0;
      Counter<F> features = example.asFeaturesCounter();
      for (F f : features.keySet()) {
        int value = (int) features.getCount(f);
        score += weight(l, f, Integer.valueOf(value));
        if (addZeroValued) {
          score -= weight(l, f, zero);
        }
      }
      scores.incrementCount(l, score);
    }
    return scores;
  }


  public L classOf(Datum<L, F> example) {
    RVFDatum<L, F> rvf = new RVFDatum<L, F>(example);
    return classOf(rvf);
  }

  public ClassicCounter<L> scoresOf(Datum<L, F> example) {
    RVFDatum<L, F> rvf = new RVFDatum<L, F>(example);
    return scoresOf(rvf);
  }

  public NaiveBayesClassifier(Counter<Pair<Pair<L, F>, Number>> weights, Counter<L> priors, Set<L> labels, Set<F> features, boolean addZero) {
    this.weights = weights;
    this.features = features;
    this.priors = priors;
    this.labels = labels;
    addZeroValued = addZero;
    if (addZeroValued) {
      initZeros();
    }
  }


  public float accuracy(Iterator<RVFDatum<L, F>> exampleIterator) {
    int correct = 0;
    int total = 0;
    for (; exampleIterator.hasNext();) {
      RVFDatum<L, F> next = exampleIterator.next();
      L guess = classOf(next);
      if (guess.equals(next.label())) {
        correct++;
      }
      total++;
    }
    System.err.println("correct " + correct + " out of " + total);
    return correct / (float) total;
  }

  public void print(PrintStream pw) {
    pw.println("priors ");
    pw.println(priors.toString());
    pw.println("weights ");
    pw.println(weights.toString());
  }

  public void print() {
    print(System.out);
  }

  private double weight(L label, F feature, Number val) {
    Pair<Pair<L, F>, Number> p = new Pair<Pair<L, F>, Number>(new Pair<L, F>(label, feature), val);
    double v = weights.getCount(p);
    return v;
  }

  public NaiveBayesClassifier(Counter<Pair<Pair<L, F>, Number>> weights, Counter<L> priors, Set<L> labels) {
    this(weights, priors, labels, null, false);
  }

