  @Override
  public Tree transformTree(Tree t, Tree root) {
    if (t == null || t.isLeaf()) {
      return t;
    }

    List<String> annotations = new ArrayList<String>();

    CoreLabel lab = (CoreLabel) t.label();
    String word = lab.word();
    String tag = lab.tag();
    String cat = lab.value();
    String baseCat = treebankLanguagePack().basicCategory(cat);

     //Tree parent = t.parent(root);

    // String mcat = "";
    // if (parent != null) {
    //   mcat = parent.label().value();
    // }

    //categories -- at present there is no tag annotation!!
    if (t.isPhrasal()) {

      List<String> childBasicCats = childBasicCats(t);

      // mark vp's headed by "zu" verbs
      if (DEBUG) {
        if (markZuVP && baseCat.equals("VP")) {
          System.out.println("child basic cats: " + childBasicCats);
        }
      }
      if (markZuVP && baseCat.equals("VP") && (childBasicCats.contains("VZ") || childBasicCats.contains("VVIZU"))) {
        if (DEBUG) System.out.println("Marked zu VP" + t);
        annotations.add("%ZU");
      }

      // mark relative clause S's
      if (markRC && (t.label() instanceof NegraLabel) && baseCat.equals("S") && ((NegraLabel) t.label()).getEdge() != null && ((NegraLabel) t.label()).getEdge().equals("RC")) {
        if (DEBUG) {
          System.out.println("annotating this guy as RC:");
          t.pennPrint();
        }
        //throw new RuntimeException("damn, not a Negra Label");

        annotations.add("%RC");
      }

//      if(t.children().length == 1) {
//        annotations.add("%U");
//      }

      if(markContainsV && containsVP(t)) {
        annotations.add("%vp");
      }

      if(markLP && leftPhrasal(t)) {
        annotations.add("%LP");
      }

      if (markKonjParent) {
        // this depends on functional tags being present
        for (String cCat : childBasicCats) {
          if (cCat.contains("-KONJ")) {
            annotations.add("%konjp");
            break;
          }
        }
      }

      if (markHDParent) {
        // this depends on functional tags being present
        for (String cCat : childBasicCats) {
          if (cCat.contains("-HD")) {
            annotations.add("%hdp");
            break;
          }
        }
      }
    } else {
      //t.isPreTerminal() case
      if (markColon && cat.equals("$.") && (word.equals(":") || word.equals(";"))) {
        annotations.add("-%colon");
      }
    }

//    if(t.isPreTerminal()) {
//      if(parent != null) {
//        String parentVal = parent.label().value();
//        int cutOffPtD = parentVal.indexOf('-');
//        int cutOffPtC = parentVal.indexOf('^');
//        int curMin = parentVal.length();
//        if(cutOffPtD != -1) {
//          curMin = cutOffPtD;
//        }
//        if(cutOffPtC != -1) {
//          curMin = Math.min(curMin, cutOffPtC);
//        }
//        parentVal = parentVal.substring(0, curMin);
//        annotations.add("^" + parentVal);
//      }
//    }
    // put on all the annotations
    StringBuilder catSB = new StringBuilder(cat);
    for (String annotation : annotations) {
      catSB.append(annotation);
    }

    t.setLabel(new CategoryWordTag(catSB.toString(), word, tag));
    return t;
  }


  private static boolean leftPhrasal(Tree t) {
    while (!t.isLeaf()) {
      t = t.lastChild();
      String str = t.label().value();
      if (str.startsWith("NP") || str.startsWith("PP") || str.startsWith("VP") || str.startsWith("S") || str.startsWith("Q") || str.startsWith("A")) {
        return true;
      }
    }
    return false;
  }

  private boolean containsVP(Tree t) {
    String cat = tlp.basicCategory(t.label().value());
    if (cat.startsWith("V")) {
      return true;
    } else {
      Tree[] kids = t.children();
      for (Tree kid : kids) {
        if (containsVP(kid)) {
          return true;
        }
      }
      return false;
    }
  }

  private List<String> childBasicCats(Tree t) {
    Tree[] kids = t.children();
    List<String> l = new ArrayList<String>();
    for (int i = 0, n = kids.length; i < n; i++) {
      l.add(basicCat(kids[i].label().value()));
    }
    return l;
  }


