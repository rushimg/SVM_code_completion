  private List<CoreLabel> classifyWithSUTime(List<CoreLabel> tokenSequence, final CoreMap document, final CoreMap sentence) {
    //
    // set everything to "O" by default
    //
    for (CoreLabel token: tokenSequence) {
      if (token.get(CoreAnnotations.AnswerAnnotation.class) == null)
        token.set(CoreAnnotations.AnswerAnnotation.class, flags.backgroundSymbol);
    }

    //
    // run SUTime
    // note: SUTime requires TextAnnotation to be set at document/sent level and
    //   This is guaranteed because here we work on a copy generated by copyTokens()
    //
    CoreMap timeSentence = (sentence != null ?
        alignSentence(sentence) :
        buildSentenceFromTokens(tokenSequence));
    List<CoreMap> timeExpressions = runSUTime(timeSentence, document);
    List<CoreMap> numbers = timeSentence.get(CoreAnnotations.NumerizedTokensAnnotation.class);

    //
    // store DATE and TIME
    //
    if (timeExpressions != null) {
      for(CoreMap timeExpression: timeExpressions) {
        // todo [cdm 2013]: We should also store these in the Sentence, but we've just got the list of tokens here
        int start = timeExpression.get(CoreAnnotations.TokenBeginAnnotation.class);
        int end = timeExpression.get(CoreAnnotations.TokenEndAnnotation.class);
        int offset = 0;
        if(sentence != null && sentence.containsKey(CoreAnnotations.TokenBeginAnnotation.class)) {
          offset = sentence.get(CoreAnnotations.TokenBeginAnnotation.class);
        }
        Timex timex = timeExpression.get(TimeAnnotations.TimexAnnotation.class);
        if(timex != null){
          if(DEBUG){
            System.err.println("FOUND DATE/TIME \"" + timeExpression +
                "\" with offsets " + start + " " + end +
                " and value " + timex);
            System.err.println("The above CoreMap has the following fields:");
            // for(Class key: timeExpression.keySet()) System.err.println("\t" + key + ": " + timeExpression.get(key));
          }
          String label = timex.timexType();
          for(int i = start; i < end; i ++){
            CoreLabel token = tokenSequence.get(i - offset);
            if(token.get(CoreAnnotations.AnswerAnnotation.class).equals(flags.backgroundSymbol)){
              token.set(CoreAnnotations.AnswerAnnotation.class, label);
              token.set(TimeAnnotations.TimexAnnotation.class, timex);
            }
          }
        }
      }
    }

    //
    // store the numbers found by SUTime as NUMBER if they are not part of anything else
    //
    if(numbers != null){
      for(CoreMap number: numbers) {
        if(number.containsKey(CoreAnnotations.NumericCompositeValueAnnotation.class)){
          int start = number.get(CoreAnnotations.TokenBeginAnnotation.class);
          int end = number.get(CoreAnnotations.TokenEndAnnotation.class);
          int offset = 0;
          if(sentence != null && sentence.containsKey(CoreAnnotations.TokenBeginAnnotation.class)) {
            offset = sentence.get(CoreAnnotations.TokenBeginAnnotation.class);
          }
          String type = number.get(CoreAnnotations.NumericCompositeTypeAnnotation.class);
          Number value = number.get(CoreAnnotations.NumericCompositeValueAnnotation.class);
          if(type != null){
            if(DEBUG) System.err.println("FOUND NUMBER \"" + number + "\" with offsets " + start + " " + end + " and value " + value + " and type " + type);
            for(int i = start; i < end; i ++){
              CoreLabel token = tokenSequence.get(i - offset);
              if(token.get(CoreAnnotations.AnswerAnnotation.class).equals(flags.backgroundSymbol)){
                token.set(CoreAnnotations.AnswerAnnotation.class, type);
                if(value != null){
                  token.set(CoreAnnotations.NumericCompositeValueAnnotation.class, value);
                }
              }
            }
          }
        }
      }
    }
    // everything tagged as CD is also a number
    // NumberNormalizer probably catches these but let's be safe
    for(CoreLabel token: tokenSequence) {
      if(token.tag().equals("CD") &&
         token.get(CoreAnnotations.AnswerAnnotation.class).equals(flags.backgroundSymbol)){
        token.set(CoreAnnotations.AnswerAnnotation.class, "NUMBER");
      }
    }

    // extract money and percents
    moneyAndPercentRecognizer(tokenSequence);

    // ordinals
    // NumberNormalizer probably catches these but let's be safe
    ordinalRecognizer(tokenSequence);

    return tokenSequence;
  }

