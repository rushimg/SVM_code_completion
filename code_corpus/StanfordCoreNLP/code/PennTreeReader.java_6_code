  @Override
  public Tree readTree() throws IOException {
    Tree t = null;

    while (tokenizer.hasNext() && t == null) {

      //Setup PDA
      this.currentTree = null;
      this.stack = new ArrayList<Tree>();

      try {
        t = getTreeFromInputStream();
      } catch (NoSuchElementException e) {
        throw new IOException("End of token stream encountered before parsing could complete.");
      }

      if (t != null) {
        // cdm 20100618: Don't do this!  This was never the historical behavior!!!
        // Escape empty trees e.g. (())
        // while(t != null && (t.value() == null || t.value().equals("")) && t.numChildren() <= 1)
        //   t = t.firstChild();

        if (treeNormalizer != null && treeFactory != null) {
          t = treeNormalizer.normalizeWholeTree(t, treeFactory);
        }
        t.indexLeaves(true);
      }
    }

    return t;
  }

  private static final Pattern SLASH_PATTERN = Pattern.compile("\\\\/");


  private Tree getTreeFromInputStream() throws NoSuchElementException {
    int wordIndex = 1;

    // FSA
    while (tokenizer.hasNext()) {
      String token = tokenizer.next();

      if (token.equals(leftParen)) {

        // cdm 20100225: This next line used to have "" instead of null, but the traditional and current tree normalizers depend on the label being null not "" when there is no label on a tree (like the outermost English PTB level)
        String label = (tokenizer.peek().equals(leftParen)) ? null : tokenizer.next();
        if (rightParen.equals(label)) {//Skip past empty trees
          continue;
        } else if (treeNormalizer != null) {
          label = treeNormalizer.normalizeNonterminal(label);
        }

        if (label != null) {
          label = SLASH_PATTERN.matcher(label).replaceAll("/");
        }

        Tree newTree = treeFactory.newTreeNode(label, null); // dtrs are added below
        if(currentTree == null)
          stack.add(newTree);
        else {
          currentTree.addChild(newTree);
          stack.add(currentTree);
        }

        currentTree = newTree;

      } else if(token.equals(rightParen)) {
        if (stack.isEmpty()) {
          // Warn that file has too many right parens
          System.err.println("PennTreeReader: warning: file has extra non-matching right parenthesis [ignored]");
          break;
        }

        //Accept
        currentTree = stack.remove(stack.size() - 1);  // i.e., stack.pop()
        if (stack.isEmpty()) return currentTree;

      } else {

        if (currentTree == null) {
          // A careful Reader should warn here, but it's kind of useful to
          // suppress this because then the TreeReader doesn't print a ton of
          // messages if there is a README file in a directory of Trees.
          // System.err.println("PennTreeReader: warning: file has extra token not in a s-expression tree: " + token + " [ignored]");
          break;
        }

        String terminal = (treeNormalizer == null) ? token : treeNormalizer.normalizeTerminal(token);
        terminal = SLASH_PATTERN.matcher(terminal).replaceAll("/");
        Tree leaf = treeFactory.newLeaf(terminal);
        if(leaf.label() instanceof HasIndex) {
          HasIndex hi = (HasIndex) leaf.label();
          hi.setIndex(wordIndex);
        }
        if(leaf.label() instanceof HasWord) {
          HasWord hw = (HasWord) leaf.label();
          hw.setWord(leaf.label().value());
        }
        wordIndex++;

        currentTree.addChild(leaf);
        // cdm: Note: this implementation just isn't as efficient as the old recursive descent parser (see 2008 code), where all the daughters are gathered before the tree is made....
      }
    }

    //Reject
    if (currentTree != null) {
      System.err.println("PennTreeReader: warning: incomplete tree (extra left parentheses in input): " + currentTree);
    }
    return null;
  }


