    public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){
      //--Preparation
      //(variables)
      final AtomicBoolean haveStarted = new AtomicBoolean(false);
      final ReentrantLock metaInfoLock = new ReentrantLock();
      final AtomicInteger numPending = new AtomicInteger(0);
      final Iterator<Runnable> iter = runnables.iterator();
      //--Create Runnables
      return new IterableIterator<Runnable>(new Iterator<Runnable>() {
        @Override
        public boolean hasNext() {
          synchronized (iter) {
            return iter.hasNext();
          }
        }
        @Override
        public synchronized Runnable next() {
          final Runnable runnable;
          synchronized (iter) {
            runnable = iter.next();
          }
          // (don't flood the queu)
          while (numPending.get() > 100) {
            try { Thread.sleep(100); }
            catch (InterruptedException e) { }
          }
          numPending.incrementAndGet();
          // (add the job)
          Runnable toReturn = new Runnable(){
            public void run(){
              boolean threadFinished = false;
              try{
                //(signal start of threads)
                metaInfoLock.lock();
                if(!haveStarted.getAndSet(true)){
                  startThreads(title); //<--this must be a blocking operation
                }
                metaInfoLock.unlock();
                //(run runnable)
                try{
                  runnable.run();
                } catch (Exception e){
                  e.printStackTrace();
                  System.exit(1);
                } catch (AssertionError e) {
                  e.printStackTrace();
                  System.exit(1);
                }
                //(signal end of thread)
                finishThread();
                threadFinished = true;
                //(signal end of threads)
                int numStillPending = numPending.decrementAndGet();
                synchronized (iter) {
                  if (numStillPending <= 0 && !iter.hasNext()) {
                    endThreads(title);
                  }
                }
              } catch(Throwable t){
                t.printStackTrace();
                if (!threadFinished) { finishThread(); }
              }
            }
          };
          return toReturn;
        }

        @Override
        public void remove() {
          synchronized (iter) {
            iter.remove();
          }
        }
      });
    }

    public static Iterable<Runnable> thread(Iterable<Runnable> runnables){ return thread("", runnables); }

