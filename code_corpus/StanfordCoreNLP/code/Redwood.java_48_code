    public static void threadAndRun(String title, Iterable<Runnable> runnables, int numThreads){
      // (short circuit if single thread)
      if (numThreads <= 1 || isThreaded || (runnables instanceof Collection && ((Collection<Runnable>) runnables).size() <= 1)) {
        startTrack( "Threads (" + title + ")" );
        for (Runnable toRun : runnables) { toRun.run(); }
        endTrack( "Threads (" + title + ")" );
        return;
      }
      //(create executor)
      ExecutorService exec = Executors.newFixedThreadPool(numThreads);
      //(add threads)
      for(Runnable toRun : thread(title,runnables)){
        exec.submit(toRun);
      }
      //(await finish)
      exec.shutdown();
      try {
        exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
      } catch (InterruptedException e) {
      }
    }
    public static void threadAndRun(String title, Iterable<Runnable> runnables){
      threadAndRun(title,runnables,Runtime.getRuntime().availableProcessors());
    }
    public static void threadAndRun(Iterable<Runnable> runnables, int numThreads){
      threadAndRun(""+numThreads, runnables, numThreads);
    }
    public static void threadAndRun(Iterable<Runnable> runnables){
      threadAndRun(runnables, Execution.threads);
    }

