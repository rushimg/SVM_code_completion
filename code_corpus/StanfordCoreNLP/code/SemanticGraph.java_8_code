  public IndexedWord getCommonAncestor(IndexedWord v1, IndexedWord v2) {
    if (this.isAncestor(v1, v2) >= 1) {
      return v2;
    }

    if (this.isAncestor(v2, v1) >= 1) {
      return v1;
    }

    List<IndexedWord> v1Parents = this.getParentList(v1);
    List<IndexedWord> v2Parents = this.getParentList(v2);
    List<IndexedWord> v1GrandParents = new ArrayList<IndexedWord>();
    List<IndexedWord> v2GrandParents = new ArrayList<IndexedWord>();
    // does v1 have any parents that are v2's parents?

    for (IndexedWord v1Parent : v1Parents) {
      if (v2Parents.contains(v1Parent)) {
        return v1Parent;
      }
      v1GrandParents.addAll(this.getParentList(v1Parent));
    }
    // does v1 have any grandparents that are v2's parents?
    for (IndexedWord v1GrandParent : v1GrandParents) {
      if (v2Parents.contains(v1GrandParent)) {
        return v1GrandParent;
      }
    }
    // build v2 grandparents
    for (IndexedWord v2Parent : v2Parents) {
      v2GrandParents.addAll(this.getParentList(v2Parent));
    }
    // does v1 have any parents or grandparents that are v2's grandparents?
    for (IndexedWord v2GrandParent : v2GrandParents) {
      if (v1Parents.contains(v2GrandParent)) {
        return v2GrandParent;
      }
      if (v1GrandParents.contains(v2GrandParent)) {
        return v2GrandParent;
      }
    }
    return null;
  }

  // todo [cdm 2013]: Completely RTE-specific methods like this one should be used to a static class of helper methods under RTE
  // If "det" is true, the search for a child is restricted to the "determiner"
  // grammatical relation.
  public boolean matchPatternToVertex(String pattern, IndexedWord vertex, boolean det) {
    if (!vertexSet().contains(vertex)) {
      throw new IllegalArgumentException();
    }
    String pat = pattern.replaceAll("<", ",<");
    pat = pat.replaceAll(">", ",>");
    String[] nodePath = pat.split(",");
    for (String s : nodePath) {
      if (s.equals("")) {
        continue;
      }
      String word = s.substring(1);
      char dir = s.charAt(0);
      if (dir == '<') {
        // look for a matching parent
        List<IndexedWord> parents = getParentList(vertex);
        boolean match = false;
        for (IndexedWord parent : parents) {
          String lemma = parent.get(CoreAnnotations.LemmaAnnotation.class);
          if (lemma.equals(word)) {
            match = true;
            break;
          }
        }
        if (!match) {
          return false;
        }
      } else if (dir == '>') {
        if (det) {
          // look for a matching child with "det" relation
          List<IndexedWord> children = getChildrenWithReln(vertex, EnglishGrammaticalRelations.DETERMINER);
          children.addAll(getChildrenWithReln(vertex, EnglishGrammaticalRelations.PREDETERMINER));
          boolean match = false;
          for (IndexedWord child : children) {
            String lemma = child.get(CoreAnnotations.LemmaAnnotation.class);
            if (lemma.equals("")) {
              lemma = child.word().toLowerCase();
            }
            if (lemma.equals(word)) {
              match = true;
              break;
            }
          }
          if (!match) {
            return false;
          }
        } else {// take any relation, except "det"
          List<Pair<GrammaticalRelation, IndexedWord>> children = childPairs(vertex);
          boolean match = false;
          for (Pair<GrammaticalRelation, IndexedWord> pair : children) {
            if (pair.first().toString().equals("det"))
              continue;
            IndexedWord child = pair.second();
            String lemma = child.get(CoreAnnotations.LemmaAnnotation.class);
            if (lemma.equals("")) {
              lemma = child.word().toLowerCase();
            }
            if (lemma.equals(word)) {
              match = true;
              break;
            }
          }
          if (!match) {
            return false;
          }
        }
      } else {
        throw new RuntimeException("Warning: bad pattern \"%s\"\n" + pattern);
      }
    }
    return true;
  }

  // todo [cdm 2013]: Completely RTE-specific methods like this one should be used to a static class of helper methods under RTE
  public boolean matchPatternToVertex(String pattern, IndexedWord vertex) {
    if (!vertexSet().contains(vertex)) {
      throw new IllegalArgumentException();
    }
    String pat = pattern.replaceAll("<", ",<");
    pat = pat.replaceAll(">", ",>");
    String[] nodePath = pat.split(",");
    for (String s : nodePath) {
      if (s.equals("")) {
        continue;
      }
      String word = s.substring(1);
      char dir = s.charAt(0);
      if (dir == '<') {
        // look for a matching parent
        List<IndexedWord> parents = getParentList(vertex);
        boolean match = false;
        for (IndexedWord parent : parents) {
          String lemma = parent.get(CoreAnnotations.LemmaAnnotation.class);
          if (lemma.equals(word)) {
            match = true;
            break;
          }
        }
        if (!match) {
          return false;
        }
      } else if (dir == '>') {
        // look for a matching child
        List<IndexedWord> children = getChildList(vertex);
        boolean match = false;
        for (IndexedWord child : children) {
          String lemma = child.get(CoreAnnotations.LemmaAnnotation.class);
          if (lemma == null || lemma.equals("")) {
            lemma = child.word().toLowerCase();
          }
          if (lemma.equals(word)) {
            match = true;
            break;
          }
        }
        if (!match) {
          return false;
        }
      } else {
        throw new RuntimeException("Warning: bad pattern \"%s\"\n" + pattern);
      }
    }
    return true;
  }

  public List<IndexedWord> getChildList(IndexedWord vertex) {
    if (!vertexSet().contains(vertex)) {
      System.err.println("Weird vertex: Index " + vertex.index() + ", word " + vertex.word());
      System.err.println("Vertices I know: " + vertexSet());
      throw new IllegalArgumentException();
    }
    List<IndexedWord> result = new ArrayList<IndexedWord>(getChildren(vertex));
    Collections.sort(result);
    return result;
  }

  public Collection<IndexedWord> getChildren(IndexedWord vertex) {
    List<IndexedWord> result = new ArrayList<IndexedWord>();
    for (SemanticGraphEdge edge : outgoingEdgeIterable(vertex)) {
      IndexedWord child = edge.getTarget();
      result.add(child);
    }
    return result;
  }

  public boolean hasChildren(IndexedWord vertex) {
    for (SemanticGraphEdge edge : outgoingEdgeIterable(vertex)) {
      return true;
    }
    return false;
  }

  public List<SemanticGraphEdge> getIncomingEdgesSorted(IndexedWord vertex) {
    List<SemanticGraphEdge> edges = incomingEdgeList(vertex);
    Collections.sort(edges);
    return edges;
  }

  public List<SemanticGraphEdge> getOutEdgesSorted(IndexedWord vertex) {
    List<SemanticGraphEdge> edges = outgoingEdgeList(vertex);
    Collections.sort(edges);
    return edges;
  }

  public List<IndexedWord> getParentList(IndexedWord vertex) {
    if (!vertexSet().contains(vertex)) {
      throw new IllegalArgumentException();
    }
    List<IndexedWord> result = new ArrayList<IndexedWord>(getParents(vertex));
    Collections.sort(result);
    return result;
  }

  public Collection<IndexedWord> getParents(IndexedWord vertex) {
    List<IndexedWord> result = new ArrayList<IndexedWord>();
    for (SemanticGraphEdge edge : incomingEdgeIterable(vertex)) {
      IndexedWord parent = edge.getSource();
      result.add(parent);
    }
    return result;
  }

