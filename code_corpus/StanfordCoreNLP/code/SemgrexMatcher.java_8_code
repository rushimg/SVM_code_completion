  public boolean find() {
    // System.err.println("hyp: " + hyp);
    if (findIterator == null) {
      try {
        if (hyp)
          findIterator = sg.topologicalSort().iterator();
        else if (sg_aligned == null)
          return false;
        else
          findIterator = sg_aligned.topologicalSort().iterator();
    			
      } catch (Exception ex) {
        if (hyp)
          findIterator = sg.vertexSet().iterator();
        else if (sg_aligned == null)
          return false;
        else
          findIterator = sg_aligned.vertexSet().iterator();
      }
    }
  //  System.out.println("first");
    if (findCurrent != null && matches()) {
    //		System.err.println("find first: " + findCurrent.word());
      return true;
    }
    //System.err.println("here");
    while (findIterator.hasNext()) {
      findCurrent = findIterator.next();
     // System.out.println("final: " + namesToNodes);
      resetChildIter(findCurrent);
      // System.out.println("after reset: " + namesToNodes);
      // Should not be necessary to reset namesToNodes here, since it
      // gets cleaned up by resetChildIter
      //namesToNodes.clear();
      //namesToRelations.clear();
      if (matches()) {
    	//  System.err.println("find second: " + findCurrent.word());
        return true;
      }
    }
    return false;
  }

