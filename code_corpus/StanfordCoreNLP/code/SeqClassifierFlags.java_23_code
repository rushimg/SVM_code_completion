      } else if (key.equalsIgnoreCase("useBig5")) {
        useBig5 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegDict2")) {
        useNegDict2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegDict3")) {
        useNegDict3 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegDict4")) {
        useNegDict4 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegCTBDict2")) {
        useNegCTBDict2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegCTBDict3")) {
        useNegCTBDict3 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegCTBDict4")) {
        useNegCTBDict4 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegASBCDict2")) {
        useNegASBCDict2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegASBCDict3")) {
        useNegASBCDict3 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegASBCDict4")) {
        useNegASBCDict4 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegPKDict2")) {
        useNegPKDict2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegPKDict3")) {
        useNegPKDict3 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegPKDict4")) {
        useNegPKDict4 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegHKDict2")) {
        useNegHKDict2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegHKDict3")) {
        useNegHKDict3 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNegHKDict4")) {
        useNegHKDict4 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("usePre")) {
        usePre = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useSuf")) {
        useSuf = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useRule")) {
        useRule = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useAs")) {
        useAs = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("usePk")) {
        usePk = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useHk")) {
        useHk = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useMsr")) {
        useMsr = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useMSRChar2")) {
        useMSRChar2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useFeaturesC4gram")) {
        useFeaturesC4gram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useFeaturesC5gram")) {
        useFeaturesC5gram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useFeaturesC6gram")) {
        useFeaturesC6gram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useFeaturesCpC4gram")) {
        useFeaturesCpC4gram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useFeaturesCpC5gram")) {
        useFeaturesCpC5gram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useFeaturesCpC6gram")) {
        useFeaturesCpC6gram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useUnicodeType")) {
        useUnicodeType = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useUnicodeBlock")) {
        useUnicodeBlock = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useUnicodeType4gram")) {
        useUnicodeType4gram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useUnicodeType5gram")) {
        useUnicodeType5gram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useShapeStrings1")) {
        useShapeStrings1 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useShapeStrings3")) {
        useShapeStrings3 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useShapeStrings4")) {
        useShapeStrings4 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useShapeStrings5")) {
        useShapeStrings5 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useWordUTypeConjunctions2")) {
        useWordUTypeConjunctions2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useWordUTypeConjunctions3")) {
        useWordUTypeConjunctions3 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useWordShapeConjunctions2")) {
        useWordShapeConjunctions2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useWordShapeConjunctions3")) {
        useWordShapeConjunctions3 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useMidDotShape")) {
        useMidDotShape = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("augmentedDateChars")) {
        augmentedDateChars = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("suppressMidDotPostprocessing")) {
        suppressMidDotPostprocessing = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("printNR")) {
        printNR = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("use4Clique")) {
        use4Clique = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useFilter")) {
        useFilter = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("largeChSegFile")) {
        largeChSegFile = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("keepEnglishWhitespaces")) {
        keepEnglishWhitespaces = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("keepAllWhitespaces")) {
        keepAllWhitespaces = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("sighanPostProcessing")) {
        sighanPostProcessing = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useChPos")) {
        useChPos = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("sighanCorporaDict")) {
        sighanCorporaDict = val;
        // end chinese word-segmenter features
      } else if (key.equalsIgnoreCase("useObservedSequencesOnly")) {
        useObservedSequencesOnly = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("maxDocSize")) {
        maxDocSize = Integer.parseInt(val);
        splitDocuments = true;
      } else if (key.equalsIgnoreCase("printProbs")) {
        printProbs = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("printFirstOrderProbs")) {
        printFirstOrderProbs = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("saveFeatureIndexToDisk")) {
        saveFeatureIndexToDisk = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("removeBackgroundSingletonFeatures")) {
        removeBackgroundSingletonFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("doGibbs")) {
        doGibbs = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNERPrior")) {
        useNERPrior = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useAcqPrior")) {
        useAcqPrior = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useSemPrior")) {
        useSemPrior = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useMUCFeatures")) {
        useMUCFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("initViterbi")) {
        initViterbi = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("checkNameList")) {
        checkNameList = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useFirstWord")) {
        useFirstWord = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useUnknown")) {
        useUnknown = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("cacheNGrams")) {
        cacheNGrams = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNumberFeature")) {
        useNumberFeature = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("annealingRate")) {
        annealingRate = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("annealingType")) {
        if (val.equalsIgnoreCase("linear") || val.equalsIgnoreCase("exp") || val.equalsIgnoreCase("exponential")) {
          annealingType = val;
        } else {
          System.err.println("unknown annealingType: " + val + ".  Please use linear|exp|exponential");
        }
      } else if (key.equalsIgnoreCase("numSamples")) {
        numSamples = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("inferenceType")) {
        inferenceType = val;
      } else if (key.equalsIgnoreCase("loadProcessedData")) {
        loadProcessedData = val;
      } else if (key.equalsIgnoreCase("normalizationTable")) {
        normalizationTable = val;
      } else if (key.equalsIgnoreCase("dictionary")) {
        // don't set if empty string or spaces or true: revert it to null
        // special case so can empty out dictionary list on command line!
        val = val.trim();
        if (val.length() > 0 && !"true".equals(val) && !"null".equals(val) && !"false".equals("val")) {
          dictionary = val;
        } else {
          dictionary = null;
        }
      } else if (key.equalsIgnoreCase("serDictionary")) {
        // don't set if empty string or spaces or true: revert it to null
        // special case so can empty out dictionary list on command line!
        val = val.trim();
        if (val.length() > 0 && !"true".equals(val) && !"null".equals(val) && !"false".equals("val")) {
          serializedDictionary = val;
        } else {
          serializedDictionary = null;
        }
      } else if (key.equalsIgnoreCase("dictionary2")) {
        // don't set if empty string or spaces or true: revert it to null
        // special case so can empty out dictionary list on command line!
        val = val.trim();
        if (val.length() > 0 && !"true".equals(val) && !"null".equals(val) && !"false".equals("val")) {
          dictionary2 = val;
        } else {
          dictionary2 = null;
        }
      } else if (key.equalsIgnoreCase("normTableEncoding")) {
        normTableEncoding = val;
      } else if (key.equalsIgnoreCase("useLemmaAsWord")) {
        useLemmaAsWord = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("type")) {
        type = val;
      } else if (key.equalsIgnoreCase("readerAndWriter")) {
        readerAndWriter = val;
      } else if (key.equalsIgnoreCase("plainTextDocumentReaderAndWriter")) {
        plainTextDocumentReaderAndWriter = val;
      } else if (key.equalsIgnoreCase("gazFilesFile")) {
        gazFilesFile = val;
      } else if (key.equalsIgnoreCase("baseTrainDir")) {
        baseTrainDir = val;
      } else if (key.equalsIgnoreCase("baseTestDir")) {
        baseTestDir = val;
      } else if (key.equalsIgnoreCase("trainFiles")) {
        trainFiles = val;
      } else if (key.equalsIgnoreCase("trainFileList")) {
        trainFileList = val;
      } else if (key.equalsIgnoreCase("trainDirs")) {
        trainDirs = val;
      } else if (key.equalsIgnoreCase("testDirs")) {
        testDirs = val;
      } else if (key.equalsIgnoreCase("testFiles")) {
        testFiles = val;
      } else if (key.equalsIgnoreCase("textFiles")) {
        textFiles = val;
      } else if (key.equalsIgnoreCase("usePrediction2")) {
        usePrediction2 = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useObservedFeaturesOnly")) {
        useObservedFeaturesOnly = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("iobWrapper")) {
        iobWrapper = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useDistSim")) {
        useDistSim = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("casedDistSim")) {
        casedDistSim = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("distSimFileFormat")) {
        distSimFileFormat = val;
      } else if (key.equalsIgnoreCase("distSimMaxBits")) {
        distSimMaxBits = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("numberEquivalenceDistSim")) {
        numberEquivalenceDistSim = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("unknownWordDistSimClass")) {
        unknownWordDistSimClass = val;
      } else if (key.equalsIgnoreCase("useOnlySeenWeights")) {
        useOnlySeenWeights = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("predProp")) {
        predProp = val;
      } else if (key.equalsIgnoreCase("distSimLexicon")) {
        distSimLexicon = val;
      } else if (key.equalsIgnoreCase("useSegmentation")) {
        useSegmentation = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useInternal")) {
        useInternal = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useExternal")) {
        useExternal = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useEitherSideWord")) {
        useEitherSideWord = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useEitherSideDisjunctive")) {
        useEitherSideDisjunctive = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("featureDiffThresh")) {
        featureDiffThresh = Double.parseDouble(val);
        if (props.getProperty("numTimesPruneFeatures") == null) {
          numTimesPruneFeatures = 1;
        }
      } else if (key.equalsIgnoreCase("numTimesPruneFeatures")) {
        numTimesPruneFeatures = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("newgeneThreshold")) {
        newgeneThreshold = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("adaptFile")) {
        adaptFile = val;
      } else if (key.equalsIgnoreCase("doAdaptation")) {
        doAdaptation = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("selfTrainFile")) {
        selfTrainFile = val;
      } else if (key.equalsIgnoreCase("selfTrainIterations")) {
        selfTrainIterations = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("selfTrainWindowSize")) {
        selfTrainWindowSize = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("selfTrainConfidenceThreshold")) {
        selfTrainConfidenceThreshold = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("numFolds")) {
        numFolds = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("startFold")) {
        startFold = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("endFold")) {
        endFold = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("adaptSigma")) {
        adaptSigma = Double.parseDouble(val);
      } else if (key.startsWith("prop") && !key.equals("prop")) {
        comboProps.add(val);
      } else if (key.equalsIgnoreCase("outputFormat")) {
        outputFormat = val;
      } else if (key.equalsIgnoreCase("useSMD")) {
        useSMD = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useScaledSGD")) {
        useScaledSGD = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("scaledSGDMethod")) {
        scaledSGDMethod = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("tuneSGD")) {
        tuneSGD = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("StochasticCalculateMethod")) {
        if (val.equalsIgnoreCase("AlgorithmicDifferentiation")) {
          stochasticMethod = StochasticCalculateMethods.AlgorithmicDifferentiation;
        } else if (val.equalsIgnoreCase("IncorporatedFiniteDifference")) {
          stochasticMethod = StochasticCalculateMethods.IncorporatedFiniteDifference;
        } else if (val.equalsIgnoreCase("ExternalFinitedifference")) {
          stochasticMethod = StochasticCalculateMethods.ExternalFiniteDifference;
        }
      } else if (key.equalsIgnoreCase("initialGain")) {
        initialGain = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("stochasticBatchSize")) {
        stochasticBatchSize = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("SGD2QNhessSamples")) {
        SGD2QNhessSamples = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("useSGD")) {
        useSGD = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useInPlaceSGD")) {
        useInPlaceSGD = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useSGDtoQN")) {
        useSGDtoQN = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("SGDPasses")) {
        SGDPasses = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("QNPasses")) {
        QNPasses = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("gainSGD")) {
        gainSGD = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("useHybrid")) {
        useHybrid = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("hybridCutoffIteration")) {
        hybridCutoffIteration = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("useStochasticQN")) {
        useStochasticQN = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("outputIterationsToFile")) {
        outputIterationsToFile = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("testObjFunction")) {
        testObjFunction = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("testVariance")) {
        testVariance = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("CRForder")) {
        CRForder = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("CRFwindow")) {
        CRFwindow = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("testHessSamples")) {
        testHessSamples = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("estimateInitial")) {
        estimateInitial = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("printLabelValue")) {
        printLabelValue = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("searchGraphPrefix")) {
        searchGraphPrefix = val;
      } else if (key.equalsIgnoreCase("searchGraphPrune")) {
        searchGraphPrune = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("kBest")) {
        useKBest = true;
        kBest = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("useRobustQN")) {
        useRobustQN = true;
      } else if (key.equalsIgnoreCase("combo")) {
        combo = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("verboseForTrueCasing")) {
        verboseForTrueCasing = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("trainHierarchical")) {
        trainHierarchical = val;
      } else if (key.equalsIgnoreCase("domain")) {
        domain = val;
      } else if (key.equalsIgnoreCase("baseline")) {
        baseline = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("doFE")) {
        doFE = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("restrictLabels")) {
        restrictLabels = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("transferSigmas")) {
        transferSigmas = val;
      } else if (key.equalsIgnoreCase("announceObjectBankEntries")) {
        announceObjectBankEntries = true;
      } else if (key.equalsIgnoreCase("mixedCaseMapFile")) {
        mixedCaseMapFile = val;
      } else if (key.equalsIgnoreCase("auxTrueCaseModels")) {
        auxTrueCaseModels = val;
      } else if (key.equalsIgnoreCase("use2W")) {
        use2W = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useLC")) {
        useLC = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useYetMoreCpCShapes")) {
        useYetMoreCpCShapes = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useIfInteger")) {
        useIfInteger = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("twoStage")) {
        twoStage = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("evaluateIters")) {
        evaluateIters = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("evalCmd")) {
        evalCmd = val;
      } else if (key.equalsIgnoreCase("evaluateTrain")) {
        evaluateTrain = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("evaluateBackground")) {
        evaluateBackground = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("tuneSampleSize")) {
        tuneSampleSize = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("useTopics")) {
        useTopics = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("usePhraseFeatures")) {
        usePhraseFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("usePhraseWords")) {
        usePhraseWords = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("usePhraseWordTags")) {
        usePhraseWordTags = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("usePhraseWordSpecialTags")) {
        usePhraseWordSpecialTags = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useProtoFeatures")) {
        useProtoFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useWordnetFeatures")) {
        useWordnetFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("wikiFeatureDbFile")) {
        wikiFeatureDbFile = val;
      } else if (key.equalsIgnoreCase("tokenizerOptions")) {
        tokenizerOptions = val;
      } else if (key.equalsIgnoreCase("tokenizerFactory")) {
        tokenizerFactory = val;
      } else if (key.equalsIgnoreCase("useCommonWordsFeature")) {
        useCommonWordsFeature = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useYear")) {
        useYear = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useSentenceNumber")) {
        useSentenceNumber = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useLabelSource")) {
        useLabelSource = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("tokenFactory")) {

        tokenFactory = val;
      } else if (key.equalsIgnoreCase("tokensAnnotationClassName")) {
        tokensAnnotationClassName = val;
      } else if (key.equalsIgnoreCase("numLopExpert")) {
        numLopExpert = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("initialLopScales")) {
        initialLopScales = val;
      } else if (key.equalsIgnoreCase("initialLopWeights")) {
        initialLopWeights = val;
      } else if (key.equalsIgnoreCase("includeFullCRFInLOP")) {
        includeFullCRFInLOP = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("backpropLopTraining")) {
        backpropLopTraining = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("randomLopWeights")) {
        randomLopWeights = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("randomLopFeatureSplit")) {
        randomLopFeatureSplit = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("nonLinearCRF")) {
        nonLinearCRF = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("secondOrderNonLinear")) {
        secondOrderNonLinear = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("numHiddenUnits")) {
        numHiddenUnits = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("useOutputLayer")) {
        useOutputLayer = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useHiddenLayer")) {
        useHiddenLayer = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("gradientDebug")) {
        gradientDebug = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("checkGradient")) {
        checkGradient = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useSigmoid")) {
        useSigmoid = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("skipOutputRegularization")) {
        skipOutputRegularization = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("sparseOutputLayer")) {
        sparseOutputLayer = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("tieOutputLayer")) {
        tieOutputLayer = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("blockInitialize")) {
        blockInitialize = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("softmaxOutputLayer")) {
        softmaxOutputLayer = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("loadBisequenceClassifierEn")) {
        loadBisequenceClassifierEn = val;
      } else if (key.equalsIgnoreCase("bisequenceClassifierPropEn")) {
        bisequenceClassifierPropEn = val;
      } else if (key.equalsIgnoreCase("loadBisequenceClassifierCh")) {
        loadBisequenceClassifierCh = val;
      } else if (key.equalsIgnoreCase("bisequenceClassifierPropCh")) {
        bisequenceClassifierPropCh = val;
      } else if (key.equalsIgnoreCase("bisequenceTestFileEn")) {
        bisequenceTestFileEn = val;
      } else if (key.equalsIgnoreCase("bisequenceTestFileCh")) {
        bisequenceTestFileCh = val;
      } else if (key.equalsIgnoreCase("bisequenceTestOutputEn")) {
        bisequenceTestOutputEn = val;
      } else if (key.equalsIgnoreCase("bisequenceTestOutputCh")) {
        bisequenceTestOutputCh = val;
      } else if (key.equalsIgnoreCase("bisequenceTestAlignmentFile")) {
        bisequenceTestAlignmentFile = val;
      } else if (key.equalsIgnoreCase("bisequenceAlignmentTestOutput")) {
        bisequenceAlignmentTestOutput = val;
      } else if (key.equalsIgnoreCase("bisequencePriorType")) {
        bisequencePriorType = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("bisequenceAlignmentPriorPenaltyCh")) {
        bisequenceAlignmentPriorPenaltyCh = val;
      } else if (key.equalsIgnoreCase("bisequenceAlignmentPriorPenaltyEn")) {
        bisequenceAlignmentPriorPenaltyEn = val;
      } else if (key.equalsIgnoreCase("alignmentPruneThreshold")) {
        alignmentPruneThreshold = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("alignmentDecodeThreshold")) {
        alignmentDecodeThreshold = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("factorInAlignmentProb")) {
        factorInAlignmentProb = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useChromaticSampling")) {
        useChromaticSampling = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useSequentialScanSampling")) {
        useSequentialScanSampling = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("maxAllowedChromaticSize")) {
        maxAllowedChromaticSize = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("keepEmptySentences")) {
        keepEmptySentences = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useBilingualNERPrior")) {
        useBilingualNERPrior = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("samplingSpeedUpThreshold")) {
        samplingSpeedUpThreshold = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("entityMatrixCh")) {
        entityMatrixCh = val;
      } else if (key.equalsIgnoreCase("entityMatrixEn")) {
        entityMatrixEn = val;
      } else if (key.equalsIgnoreCase("multiThreadGibbs")) {
        multiThreadGibbs = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("matchNERIncentive")) {
        matchNERIncentive = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useEmbedding")) {
        useEmbedding = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("prependEmbedding")) {
        prependEmbedding = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("embeddingWords")) {
        embeddingWords = val;
      } else if (key.equalsIgnoreCase("embeddingVectors")) {
        embeddingVectors = val;
      } else if (key.equalsIgnoreCase("transitionEdgeOnly")) {
        transitionEdgeOnly = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("priorLambda")) {
        priorLambda = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("addCapitalFeatures")) {
        addCapitalFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("arbitraryInputLayerSize")) {
        arbitraryInputLayerSize = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("noEdgeFeature")) {
        noEdgeFeature = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("terminateOnEvalImprovement")) {
        terminateOnEvalImprovement = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("terminateOnEvalImprovementNumOfEpoch")) {
        terminateOnEvalImprovementNumOfEpoch = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("useMemoryEvaluator")) {
        useMemoryEvaluator = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("suppressTestDebug")) {
        suppressTestDebug = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useOWLQN")) {
        useOWLQN = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("printWeights")) {
        printWeights = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("totalDataSlice")) {
        totalDataSlice = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("numOfSlices")) {
        numOfSlices = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("regularizeSoftmaxTieParam")) {
        regularizeSoftmaxTieParam = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("softmaxTieLambda")) {
        softmaxTieLambda = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("totalFeatureSlice")) {
        totalFeatureSlice = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("numOfFeatureSlices")) {
        numOfFeatureSlices = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("addBiasToEmbedding")) {
        addBiasToEmbedding = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("hardcodeSoftmaxOutputWeights")) {
        hardcodeSoftmaxOutputWeights = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNERPriorBIO")) {
        useNERPriorBIO = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("entityMatrix")) {
        entityMatrix = val;
      } else if (key.equalsIgnoreCase("multiThreadClassifier")) {
        multiThreadClassifier = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("useDualDecomp")) {
        useDualDecomp = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("biAlignmentPriorIsPMI")) {
        biAlignmentPriorIsPMI = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("dampDDStepSizeWithAlignmentProb")) {
        dampDDStepSizeWithAlignmentProb = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("dualDecompAlignment")) {
        dualDecompAlignment = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("dualDecompInitialStepSizeAlignment")) {
        dualDecompInitialStepSizeAlignment = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("dualDecompNotBIO")) {
        dualDecompNotBIO = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("berkeleyAlignerLoadPath")) {
        berkeleyAlignerLoadPath = val;
      } else if (key.equalsIgnoreCase("useBerkeleyAlignerForViterbi")) {
        useBerkeleyAlignerForViterbi = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useBerkeleyCompetitivePosterior")) {
        useBerkeleyCompetitivePosterior = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useDenero")) {
        useDenero = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("alignDDAlpha")) {
        alignDDAlpha = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("factorInBiEdgePotential")) {
        factorInBiEdgePotential = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("noNeighborConstraints")) {
        noNeighborConstraints = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("includeC2EViterbi")) {
        includeC2EViterbi = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("initWithPosterior")) {
        initWithPosterior = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("nerSlowerTimes")) {
        nerSlowerTimes = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("nerSkipFirstK")) {
        nerSkipFirstK = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("powerAlignProb")) {
        powerAlignProb = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("powerAlignProbAsAddition")) {
        powerAlignProbAsAddition = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("initWithNERPosterior")) {
        initWithNERPosterior = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("applyNERPenalty")) {
        applyNERPenalty = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useGenericFeatures")) {
        useGenericFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("printFactorTable")) {
        printFactorTable = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useAdaGradFOBOS")) {
        useAdaGradFOBOS = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("initRate")) {
        initRate = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("groupByFeatureTemplate")) {
        groupByFeatureTemplate = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("groupByOutputClass")) {
        groupByOutputClass = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("priorAlpha")) {
        priorAlpha = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("splitWordRegex")){
        splitWordRegex = val;
      } else if (key.equalsIgnoreCase("groupByInput")){
        groupByInput = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("groupByHiddenUnit")){
        groupByHiddenUnit = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("unigramLM")){
        unigramLM = val;
      } else if (key.equalsIgnoreCase("bigramLM")){
        bigramLM = val;
      } else if (key.equalsIgnoreCase("wordSegBeamSize")){
        wordSegBeamSize = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("vocabFile")){
        vocabFile = val;
      } else if (key.equalsIgnoreCase("normalizedFile")){
        normalizedFile = val;
      } else if (key.equalsIgnoreCase("averagePerceptron")){
        averagePerceptron = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("loadCRFSegmenterPath")){
        loadCRFSegmenterPath = val;
      } else if (key.equalsIgnoreCase("loadPCTSegmenterPath")){
        loadPCTSegmenterPath = val;
      } else if (key.equalsIgnoreCase("crfSegmenterProp")){
        crfSegmenterProp = val;
      } else if (key.equalsIgnoreCase("pctSegmenterProp")){
        pctSegmenterProp = val;
      } else if (key.equalsIgnoreCase("dualDecompMaxItr")){
        dualDecompMaxItr = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("dualDecompInitialStepSize")){
        dualDecompInitialStepSize = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("dualDecompDebug")){
        dualDecompDebug = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("intermediateSegmenterOut")){
        intermediateSegmenterOut = val;
      } else if (key.equalsIgnoreCase("intermediateSegmenterModel")){
        intermediateSegmenterModel = val;
      } else if (key.equalsIgnoreCase("useCWSWordFeatures")){
        useCWSWordFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useCWSWordFeaturesAll")){
        useCWSWordFeaturesAll = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useCWSWordFeaturesBigram")){
        useCWSWordFeaturesBigram = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("pctSegmenterLenAdjust")){
        pctSegmenterLenAdjust = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useTrainLexicon")){
        useTrainLexicon = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useCWSFeatures")){
        useCWSFeatures = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("appendLC")){
        appendLC = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("perceptronDebug")){
        perceptronDebug = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("pctSegmenterScaleByCRF")){
        pctSegmenterScaleByCRF = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("pctSegmenterScale")){
        pctSegmenterScale = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("separateASCIIandRange")){
        separateASCIIandRange = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("dropoutRate")){
        dropoutRate = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("dropoutScale")){
        dropoutScale = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("multiThreadGrad")){
        multiThreadGrad = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("maxQNItr")){
        maxQNItr = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("dropoutApprox")){
        dropoutApprox = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("unsupDropoutFile")){
        unsupDropoutFile = val;
      } else if (key.equalsIgnoreCase("unsupDropoutScale")){
        unsupDropoutScale = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("startEvaluateIters")){
        startEvaluateIters = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("multiThreadPerceptron")){
        multiThreadPerceptron = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("lazyUpdate")){
        lazyUpdate = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("featureCountThresh")){
        featureCountThresh = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("serializeWeightsTo")) {
        serializeWeightsTo = val;
      } else if (key.equalsIgnoreCase("geDebug")){
        geDebug = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("doFeatureDiscovery")){
        doFeatureDiscovery = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("loadWeightsFrom")) {
        loadWeightsFrom = val;
      } else if (key.equalsIgnoreCase("loadClassIndexFrom")) {
        loadClassIndexFrom = val;
      } else if (key.equalsIgnoreCase("serializeClassIndexTo")) {
        serializeClassIndexTo = val;
      } else if (key.equalsIgnoreCase("learnCHBasedOnEN")){
        learnCHBasedOnEN = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("learnENBasedOnCH")){
        learnENBasedOnCH = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("loadWeightsFromEN")){
        loadWeightsFromEN = val;
      } else if (key.equalsIgnoreCase("loadWeightsFromCH")){
        loadWeightsFromCH = val;
      } else if (key.equalsIgnoreCase("serializeToEN")){
        serializeToEN = val;
      } else if (key.equalsIgnoreCase("serializeToCH")){
        serializeToCH = val;
      } else if (key.equalsIgnoreCase("testFileEN")){
        testFileEN = val;
      } else if (key.equalsIgnoreCase("testFileCH")){
        testFileCH = val;
      } else if (key.equalsIgnoreCase("unsupFileEN")){
        unsupFileEN = val;
      } else if (key.equalsIgnoreCase("unsupFileCH")){
        unsupFileCH = val;
      } else if (key.equalsIgnoreCase("unsupAlignFile")){
        unsupAlignFile = val;
      } else if (key.equalsIgnoreCase("supFileEN")){
        supFileEN = val;
      } else if (key.equalsIgnoreCase("supFileCH")){
        supFileCH = val;
      } else if (key.equalsIgnoreCase("serializeFeatureIndexTo")){
        serializeFeatureIndexTo = val;
      } else if (key.equalsIgnoreCase("loadFeatureIndexFromEN")){
        loadFeatureIndexFromEN = val;
      } else if (key.equalsIgnoreCase("loadFeatureIndexFromCH")){
        loadFeatureIndexFromCH = val;
      } else if (key.equalsIgnoreCase("lambdaEN")){
        lambdaEN = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("lambdaCH")){
        lambdaCH = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("alternateTraining")){
        alternateTraining = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("weightByEntropy")){
        weightByEntropy = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useKL")){
        useKL = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useHardGE")){
        useHardGE = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useCRFforUnsup")){
        useCRFforUnsup = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useGEforSup")){
        useGEforSup = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useKnownLCWords")){
        useKnownLCWords = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useNoisyLabel")){
        useNoisyLabel = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("errorMatrix")) {
        errorMatrix = val;
      } else if (key.equalsIgnoreCase("printTrainLabels")){
        printTrainLabels = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("labelDictionaryCutoff")) {
        labelDictionaryCutoff = Integer.parseInt(val);
      } else if (key.equalsIgnoreCase("useAdaDelta")){
        useAdaDelta = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("useAdaDiff")){
        useAdaDiff = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("adaGradEps")){
        adaGradEps = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("adaDeltaRho")){
        adaDeltaRho = Double.parseDouble(val);
      } else if (key.equalsIgnoreCase("useRandomSeed")){
        useRandomSeed = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("terminateOnAvgImprovement")){
        terminateOnAvgImprovement = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("strictGoodCoNLL")) {
        strictGoodCoNLL = Boolean.parseBoolean(val);
      } else if (key.equalsIgnoreCase("removeStrictGoodCoNLLDuplicates")) {
        removeStrictGoodCoNLLDuplicates = Boolean.parseBoolean(val);

        // ADD VALUE ABOVE HERE
      } else if (key.length() > 0 && !key.equals("prop")) {
        System.err.println("Unknown property: |" + key + '|');
      }
    }
    if (startFold > numFolds) {
      System.err.println("startFold > numFolds -> setting startFold to 1");
      startFold = 1;
    }
    if (endFold > numFolds) {
      System.err.println("endFold > numFolds -> setting to numFolds");
      endFold = numFolds;
    }

    if (combo) {
      splitDocuments = false;
    }

    stringRep = sb.toString();
  } // end setProperties()

  // Thang Sep13: refactor to be used for multiple factories.
  private String getFeatureFactory(String val){
    if (val.equalsIgnoreCase("SuperSimpleFeatureFactory")) {
      val = "edu.stanford.nlp.sequences.SuperSimpleFeatureFactory";
    } else if (val.equalsIgnoreCase("NERFeatureFactory")) {
      val = "edu.stanford.nlp.ie.NERFeatureFactory";
    } else if (val.equalsIgnoreCase("GazNERFeatureFactory")) {
      val = "edu.stanford.nlp.sequences.GazNERFeatureFactory";
    } else if (val.equalsIgnoreCase("IncludeAllFeatureFactory")) {
      val = "edu.stanford.nlp.sequences.IncludeAllFeatureFactory";
    } else if (val.equalsIgnoreCase("PhraseFeatureFactory")) {
      val = "edu.stanford.nlp.article.extraction.PhraseFeatureFactory";
    } else if (val.equalsIgnoreCase("EmbeddingFeatureFactory")) {
      val = "edu.stanford.nlp.ie.EmbeddingFeatureFactory";
    }

    return val;
  }
