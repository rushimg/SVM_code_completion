  @SuppressWarnings("UnusedDeclaration")
  public boolean isAfter(Span otherSpan) {
    if (this.contains(otherSpan) || otherSpan.contains(this)) {
      throw new IllegalArgumentException("Span " + toString() + " contains otherSpan " + otherSpan + " (or vice versa)");
    }
    return this.start >= otherSpan.end;
  }

  @Override
  public Iterator<Integer> iterator() {
    return new Iterator<Integer>() {
      int nextIndex = start;
      @Override
      public boolean hasNext() {
        return nextIndex < end;
      }
      @Override
      public Integer next() {
        if (!hasNext()) { throw new NoSuchElementException(); }
        nextIndex += 1;
        return nextIndex - 1;
      }
      @Override
      public void remove() { throw new UnsupportedOperationException(); }
    };
  }

  public int size() {
    return end - start;
  }

  public static boolean overlaps(Span spanA, Span spanB) {
    return spanA.contains(spanB) ||
            spanB.contains(spanA) ||
            (spanA.end > spanB.end && spanA.start < spanB.end) ||
            (spanB.end > spanA.end && spanB.start < spanA.end) ||
            spanA.equals(spanB);
  }

  public static int overlap(Span spanA, Span spanB) {
    if (spanA.contains(spanB)) {
      return Math.min(spanA.end - spanA.start, spanB.end - spanB.start);
    } else if (spanA.equals(spanB)) {
      return spanA.end - spanA.start;
    } else if ( (spanA.end > spanB.end && spanA.start < spanB.end) ||
                (spanB.end > spanA.end && spanB.start < spanA.end) ) {
      return Math.min(spanA.end, spanB.end) - Math.max(spanA.start, spanB.start) ;
    } else {
      return 0;
    }
  }

  public static boolean overlaps(Span spanA, Collection<Span> spanB) {
    for (Span candidate : spanB) {
      if (overlaps(spanA, candidate)) { return true; }
    }
    return false;
  }

