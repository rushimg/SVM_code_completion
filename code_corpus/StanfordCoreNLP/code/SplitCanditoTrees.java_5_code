  private static final boolean MORFETTE_OUTPUT = false;
  
  
  // Statistics
  private static int nTokens = 0;
  private static int nMorphAnalyses = 0;
  
  private static final Integer[] fSizes = {1235,1235,9881,10000000};
  private static final String[] fNames = {"candito.test", "candito.dev",
                                  "candito.train",
                                  "candito.train.extended"};

  private SplitCanditoTrees() {} // static main method only

  static List<String> readIds(String filename)
    throws IOException
  {
    List<String> ids = new ArrayList<String>();
    BufferedReader fin =
      new BufferedReader(new InputStreamReader
                         (new FileInputStream(filename), "ISO8859_1"));
    String line;
    while ((line = fin.readLine()) != null) {
      String[] pieces = line.split("\t");
      ids.add(pieces[0].trim());
    }
    return ids;
  }

  static Map<String, Tree> readTrees(String[] filenames)
    throws IOException
  {
    // TODO: perhaps we can just pass in CC_TAGSET and get rid of replacePOSTags
    // need to test that
    final TreeReaderFactory trf = new FrenchXMLTreeReaderFactory(false); 
    Map<String, Tree> treeMap = Generics.newHashMap();
    for (String filename : filenames) {
      File file = new File(filename);
      String canonicalFilename =
        file.getName().substring(0, file.getName().lastIndexOf('.'));

      FrenchXMLTreeReader tr = (FrenchXMLTreeReader)
        trf.newTreeReader(new BufferedReader
                          (new InputStreamReader
                           (new FileInputStream(file),"ISO8859_1")));

      Tree t = null;
      int numTrees;
      for (numTrees = 0; (t = tr.readTree()) != null; numTrees++) {
        String id = canonicalFilename + "-" + ((CoreLabel) t.label()).get(CoreAnnotations.SentenceIDAnnotation.class);
        treeMap.put(id, t);
      }

      tr.close();
      System.err.printf("%s: %d trees%n", file.getName(), numTrees);
    }
    return treeMap;
  }

  static void preprocessMWEs(Map<String, Tree> treeMap) {

    TwoDimensionalCounter<String,String> labelTerm =
      new TwoDimensionalCounter<String,String>();
    TwoDimensionalCounter<String,String> termLabel =
      new TwoDimensionalCounter<String,String>();
    TwoDimensionalCounter<String,String> labelPreterm =
      new TwoDimensionalCounter<String,String>();
    TwoDimensionalCounter<String,String> pretermLabel =
      new TwoDimensionalCounter<String,String>();

    TwoDimensionalCounter<String,String> unigramTagger =
      new TwoDimensionalCounter<String,String>();

    for (Tree t : treeMap.values()) {
      MWEPreprocessor.countMWEStatistics(t, unigramTagger,
                                         labelPreterm, pretermLabel,
                                         labelTerm, termLabel);
    }

    for (Tree t : treeMap.values()) {
      MWEPreprocessor.traverseAndFix(t, pretermLabel, unigramTagger);
    }
  }

  public static void mungeLeaves(Tree tree, boolean lemmasAsLeaves, boolean addMorphoToLeaves) {
    List<Label> labels = tree.yield();
    
    for (Label label : labels) {
      ++nTokens;
      if (!(label instanceof CoreLabel)) {
        throw new IllegalArgumentException("Only works with CoreLabels trees");
      }

      CoreLabel coreLabel = (CoreLabel) label;
      String lemma = coreLabel.lemma();
      //PTB escaping since we're going to put this in the leaf
      if (lemma == null) {
        // No lemma, so just add the surface form
        lemma = coreLabel.word();
      } else if (lemma.equals("(")) {
        lemma = "-LRB-";
      } else if (lemma.equals(")")) {
        lemma = "-RRB-";
      }

      if (lemmasAsLeaves) {
        String escapedLemma = lemma;
        coreLabel.setWord(escapedLemma);
        coreLabel.setValue(escapedLemma);
        coreLabel.setLemma(lemma);
      }

      if (addMorphoToLeaves) {
        String morphStr = coreLabel.originalText();
        if(morphStr == null || morphStr.equals("")) {
          morphStr = MorphoFeatureSpecification.NO_ANALYSIS;
        } else {
          ++nMorphAnalyses;
        }
        // Normalize punctuation analyses
        if (morphStr.startsWith("PONCT")) {
          morphStr = "PUNC";
        }
        
        String newLeaf = String.format("%s%s%s%s%s", coreLabel.value(),
                                                   MorphoFeatureSpecification.MORPHO_MARK,
                                                   lemma,
                                                   MorphoFeatureSpecification.LEMMA_MARK,
                                                   morphStr);
        coreLabel.setValue(newLeaf);
        coreLabel.setWord(newLeaf);
      }
    }
  }

  private static void replacePOSTags(Tree tree) {
    List<Label> yield = tree.yield();
    List<Label> preYield = tree.preTerminalYield();

    assert yield.size() == preYield.size();

    MorphoFeatureSpecification spec = new FrenchMorphoFeatureSpecification();
    for(int i = 0; i < yield.size(); i++) {
      // Morphological Analysis
      String morphStr = ((CoreLabel) yield.get(i)).originalText();
      if (morphStr == null || morphStr.equals("")) {
        morphStr = preYield.get(i).value();
        // POS subcategory
        String subCat = ((CoreLabel) yield.get(i)).category();
        if (subCat != null && subCat != "") {
          morphStr += "-" + subCat + "--";
        } else {
          morphStr += "---";
        }
      }
      MorphoFeatures feats = spec.strToFeatures(morphStr);
      if(feats.getAltTag() != null && !feats.getAltTag().equals("")) {
        CoreLabel cl = (CoreLabel) preYield.get(i);
        cl.setValue(feats.getAltTag());
        cl.setTag(feats.getAltTag());
      }
    }
  }

