  Pair<UnaryGrammar, BinaryGrammar> bgug;

  Random random = new Random(87543875943265L);

  static final double LEX_SMOOTH = 0.0001;
  static final double STATE_SMOOTH = 0.0;

  public SplittingGrammarExtractor(Options op) {
    this.op = op;
    startSymbols = Arrays.asList(op.langpack().startSymbols());
  }

  double[] neginfDoubles(int size) {
    double[] result = new double[size];
    for (int i = 0; i < size; ++i) {
      result[i] = Double.NEGATIVE_INFINITY;
    }
    return result;
  }

  public void outputTransitions(Tree tree, 
                                IdentityHashMap<Tree, double[][]> unaryTransitions,
                                IdentityHashMap<Tree, double[][][]> binaryTransitions) {
    outputTransitions(tree, 0, unaryTransitions, binaryTransitions);
  }

  public void outputTransitions(Tree tree, int depth,
                                IdentityHashMap<Tree, double[][]> unaryTransitions,
                                IdentityHashMap<Tree, double[][][]> binaryTransitions) {
    for (int i = 0; i < depth; ++i) {
      System.out.print(" ");
    }
    if (tree.isLeaf()) {
      System.out.println(tree.label().value());
      return;
    }
    if (tree.children().length == 1) {
      System.out.println(tree.label().value() + " -> " + tree.children()[0].label().value());
      if (!tree.isPreTerminal()) {
        double[][] transitions = unaryTransitions.get(tree);
        for (int i = 0; i < transitions.length; ++i) {
          for (int j = 0; j < transitions[0].length; ++j) {
            for (int z = 0; z < depth; ++z) {
              System.out.print(" ");
            }
            System.out.println("  " + i + "," + j + ": " + transitions[i][j] + " | " + Math.exp(transitions[i][j]));
          }
        }
      }
    } else {
      System.out.println(tree.label().value() + " -> " + tree.children()[0].label().value() + " " + tree.children()[1].label().value());
      double[][][] transitions = binaryTransitions.get(tree);
      for (int i = 0; i < transitions.length; ++i) {
        for (int j = 0; j < transitions[0].length; ++j) {
          for (int k = 0; k < transitions[0][0].length; ++k) {
            for (int z = 0; z < depth; ++z) {
              System.out.print(" ");
            }
            System.out.println("  " + i + "," + j + "," + k + ": " + transitions[i][j][k] + " | " + Math.exp(transitions[i][j][k]));
          }
        }
      }
    }
    if (tree.isPreTerminal()) {
      return;
    }
    for (Tree child : tree.children()) {
      outputTransitions(child, depth + 1, unaryTransitions, binaryTransitions);
    }
  }

  public void outputBetas() {
    System.out.println("UNARY:");
    for (String parent : unaryBetas.firstKeySet()) { 
      for (String child : unaryBetas.get(parent).keySet()) {
        System.out.println("  " + parent + "->" + child);
        double[][] betas = unaryBetas.get(parent).get(child);
        int parentStates = betas.length;
        int childStates = betas[0].length;
        for (int i = 0; i < parentStates; ++i) {
          for (int j = 0; j < childStates; ++j) {
            System.out.println("    " + i + "->" + j + " " + betas[i][j] + " | " + Math.exp(betas[i][j]));
          }
        }
      }
    }
    System.out.println("BINARY:");
    for (String parent : binaryBetas.firstKeySet()) { 
      for (String left : binaryBetas.get(parent).firstKeySet()) {
        for (String right : binaryBetas.get(parent).get(left).keySet()) {
          System.out.println("  " + parent + "->" + left + "," + right);
          double[][][] betas = binaryBetas.get(parent).get(left).get(right);
          int parentStates = betas.length;
          int leftStates = betas[0].length;
          int rightStates = betas[0][0].length;
          for (int i = 0; i < parentStates; ++i) {
            for (int j = 0; j < leftStates; ++j) {
              for (int k = 0; k < rightStates; ++k) {
                System.out.println("    " + i + "->" + j + "," + k + " " + betas[i][j][k] + " | " + Math.exp(betas[i][j][k]));
              }
            }
          }
        }
      }
    }
  }

  public String state(String tag, int i) {
    if (startSymbols.contains(tag) || tag.equals(Lexicon.BOUNDARY_TAG)) {
      return tag;
    }
    return tag + "^" + i;
  }

  public int getStateSplitCount(Tree tree) {
    return stateSplitCounts.getIntCount(tree.label().value());
  }

  public int getStateSplitCount(String label) {
    return stateSplitCounts.getIntCount(label);
  }


