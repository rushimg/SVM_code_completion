  protected synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps, final AnnotatorImplementations annotatorImplementation) {
    // if the pool already exists reuse!
    if(pool == null) {
      // first time we get here
      pool = new AnnotatorPool();
    }

    //
    // tokenizer: breaks text into a sequence of tokens
    // this is required for all following annotators!
    //
    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        if (Boolean.valueOf(properties.getProperty("tokenize.whitespace",
                          "false"))) {
          return annotatorImplementation.whitespaceTokenizer(properties);
        } else {
          String options = properties.getProperty("tokenize.options", PTBTokenizerAnnotator.DEFAULT_OPTIONS);
          boolean keepNewline = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, "false"));
          // If they
          if (properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY) != null) {
            keepNewline = true;
          }
          // If the user specifies "tokenizeNLs=false" in tokenize.options, then this default will
          // be overridden.
          if (keepNewline) {
            options = "tokenizeNLs," + options;
          }
          return annotatorImplementation.ptbTokenizer(properties, false, options);
        }
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        StringBuilder os = new StringBuilder();
        os.append("tokenize.whitespace:" +
                properties.getProperty("tokenize.whitespace", "false"));
        if (properties.getProperty("tokenize.options") != null) {
          os.append(":tokenize.options:" + properties.getProperty("tokenize.options"));
        }
        if (Boolean.valueOf(properties.getProperty("tokenize.whitespace",
                "false"))) {
          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + ":" +
                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,
                          "false"));
          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + ":" +
                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,
                          "false"));
          return os.toString();
        } else {
          os.append(NEWLINE_SPLITTER_PROPERTY + ":" +
                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,
                          "false")));
          os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + ":" +
                    properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK));
        }
        return os.toString();
      }
    });

    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        String xmlTags =
          properties.getProperty("clean.xmltags",
                            CleanXmlAnnotator.DEFAULT_XML_TAGS);
        String sentenceEndingTags =
          properties.getProperty("clean.sentenceendingtags",
                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);
        String singleSentenceTags =
                properties.getProperty("clean.singlesentencetags",
                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);
        String allowFlawedString = properties.getProperty("clean.allowflawedxml");
        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;
        if (allowFlawedString != null)
          allowFlawed = Boolean.valueOf(allowFlawedString);
        String dateTags =
          properties.getProperty("clean.datetags",
                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);
        String docIdTags =
                properties.getProperty("clean.docIdtags",
                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);
        String docTypeTags =
                properties.getProperty("clean.docTypetags",
                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);
        String utteranceTurnTags =
                properties.getProperty("clean.turntags",
                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);
        String speakerTags =
                properties.getProperty("clean.speakertags",
                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);
        String docAnnotations =
                properties.getProperty("clean.docAnnotations",
                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);
        String tokenAnnotations =
                properties.getProperty("clean.tokenAnnotations",
                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);
        String sectionTags =
                properties.getProperty("clean.sectiontags",
                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);
        String sectionAnnotations =
                properties.getProperty("clean.sectionAnnotations",
                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);
        String ssplitDiscardTokens =
                properties.getProperty("clean.ssplitDiscardTokens");
        CleanXmlAnnotator annotator = annotatorImplementation.cleanXML(properties, xmlTags,
            sentenceEndingTags,
            dateTags,
            allowFlawed);
        annotator.setSingleSentenceTagMatcher(singleSentenceTags);
        annotator.setDocIdTagMatcher(docIdTags);
        annotator.setDocTypeTagMatcher(docTypeTags);
        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);
        annotator.setDocAnnotationPatterns(docAnnotations);
        annotator.setTokenAnnotationPatterns(tokenAnnotations);
        annotator.setSectionTagMatcher(sectionTags);
        annotator.setSectionAnnotationPatterns(sectionAnnotations);
        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);
        return annotator;
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        return "clean.xmltags:" +
                properties.getProperty("clean.xmltags",
                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +
                "clean.sentenceendingtags:" +
                properties.getProperty("clean.sentenceendingtags",
                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +
                "clean.sentenceendingtags:" +
                properties.getProperty("clean.singlesentencetags",
                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +
                "clean.allowflawedxml:" +
                properties.getProperty("clean.allowflawedxml", "") +
                "clean.datetags:" +
                properties.getProperty("clean.datetags",
                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +
                "clean.docidtags:" +
                properties.getProperty("clean.docid",
                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +
                "clean.doctypetags:" +
                properties.getProperty("clean.doctype",
                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +
                "clean.turntags:" +
                properties.getProperty("clean.turntags",
                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +
                "clean.speakertags:" +
                properties.getProperty("clean.speakertags",
                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +
                "clean.docAnnotations:" +
                properties.getProperty("clean.docAnnotations",
                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +
                "clean.tokenAnnotations:" +
                properties.getProperty("clean.tokenAnnotations",
                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +
                "clean.sectiontags:" +
                properties.getProperty("clean.sectiontags",
                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +
                "clean.sectionAnnotations:" +
                properties.getProperty("clean.sectionAnnotations",
                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);
      }
    });

    //
    // Sentence splitter: splits the above sequence of tokens into
    // sentences.  This is required when processing entire documents or
    // text consisting of multiple sentences.
    //
    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        System.err.println(signature());
        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, "false"));
        if (nlSplitting) {
          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty("tokenize.whitespace", "false"));
          if (whitespaceTokenization) {
            if (System.getProperty("line.separator").equals("\n")) {
              return WordsToSentencesAnnotator.newlineSplitter(false, "\n");
            } else {
              // throw "\n" in just in case files use that instead of
              // the system separator
              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty("line.separator"), "\n");
            }
          } else {
            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());
          }

        } else {
          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.
          String isOneSentence = properties.getProperty("ssplit.isOneSentence");
          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false
            return WordsToSentencesAnnotator.nonSplitter(false);
          }

          // multi token sentence boundaries
          String boundaryMultiTokenRegex = properties.getProperty("ssplit.boundaryMultiTokenRegex");

          // Discard these tokens without marking them as sentence boundaries
          String tokenPatternsToDiscardProp = properties.getProperty("ssplit.tokenPatternsToDiscard");
          Set<String> tokenRegexesToDiscard = null;
          if (tokenPatternsToDiscardProp != null){
            String [] toks = tokenPatternsToDiscardProp.split(",");
            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));
          }
          // regular boundaries
          String boundaryTokenRegex = properties.getProperty("ssplit.boundaryTokenRegex");
          Set<String> boundariesToDiscard = null;

          // newline boundaries which are discarded.
          String bounds = properties.getProperty("ssplit.boundariesToDiscard");
          if (bounds != null) {
            String [] toks = bounds.split(",");
            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));
          }
          Set<String> htmlElementsToDiscard = null;
          // HTML boundaries which are discarded
          bounds = properties.getProperty("ssplit.htmlBoundariesToDiscard");
          if (bounds != null) {
            String [] elements = bounds.split(",");
            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));
          }
          String nlsb = properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY, DEFAULT_NEWLINE_IS_SENTENCE_BREAK);

          return annotatorImplementation.wordToSentences(properties,
              false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,
              nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);
        }
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        StringBuilder os = new StringBuilder();
        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, "false"))) {
          os.append(NEWLINE_SPLITTER_PROPERTY + "=").append(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, "false")).append("\n");
          os.append("tokenize.whitespace=").append(properties.getProperty("tokenize.whitespace", "false")).append("\n");
        } else {
          os.append(baseSignature(properties, STANFORD_SSPLIT));
        }
        return os.toString();
      }
    });

    //
    // POS tagger
    //
    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        try {
          return annotatorImplementation.posTagger(properties);
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        return POSTaggerAnnotator.signature(properties);
      }
    });

    //
    // Lemmatizer
    //
    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        return annotatorImplementation.morpha(properties, false);
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        // nothing for this one
        return "";
      }
    });

    //
    // NER
    //
    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        try {
          return annotatorImplementation.ner(properties);
        } catch (FileNotFoundException e) {
          throw new RuntimeIOException(e);
        }
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        return "ner.model:" +
                properties.getProperty("ner.model", "") +
                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + ":" +
                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,
                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +
                NumberSequenceClassifier.USE_SUTIME_PROPERTY + ":" +
                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,
                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));
      }
    });

    //
    // Regex NER
    //
    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        return annotatorImplementation.tokensRegexNER(properties, "regexner");
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        return PropertiesUtils.getSignature("regexner", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);
      }
    });

    //
    // Gender Annotator
    //
    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        return annotatorImplementation.gender(properties, false);
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        return "gender.firstnames:" +
                properties.getProperty("gender.firstnames",
                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);
      }
    });


    //
    // True caser
    //
    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        String model = properties.getProperty("truecase.model", DefaultPaths.DEFAULT_TRUECASE_MODEL);
        String bias = properties.getProperty("truecase.bias", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);
        String mixed = properties.getProperty("truecase.mixedcasefile", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);
        return annotatorImplementation.trueCase(properties, model, bias, mixed, false);
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        return "truecase.model:" +
                properties.getProperty("truecase.model",
                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +
                "truecase.bias:" +
                properties.getProperty("truecase.bias",
                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +
                "truecase.mixedcasefile:" +
                properties.getProperty("truecase.mixedcasefile",
                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);
      }
    });

    //
    // Parser
    //
    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        return annotatorImplementation.parse(properties);
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        String type = properties.getProperty("parse.type", "stanford");
        if(type.equalsIgnoreCase("stanford")){
          return ParserAnnotator.signature("parse", properties);
        } else if(type.equalsIgnoreCase("charniak")) {
          return "parse.model:" +
                  properties.getProperty("parse.model", "") +
                  "parse.executable:" +
                  properties.getProperty("parse.executable", "") +
                  "parse.maxlen:" +
                  properties.getProperty("parse.maxlen", "");
        } else {
          throw new RuntimeException("Unknown parser type: " + type +
                  " (currently supported: stanford and charniak)");
        }
      }
    });

    //
    // Coreference resolution
    //
    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        return annotatorImplementation.coref(properties);
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        return DeterministicCorefAnnotator.signature(properties);
      }
    });

    // add annotators loaded via reflection from classnames specified
    // in the properties
    for (Object propertyKey : inputProps.stringPropertyNames()) {
      if (!(propertyKey instanceof String))
        continue; // should this be an Exception?
      final String property = (String) propertyKey;
      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {
        final String customName =
          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());
        final String customClassName = inputProps.getProperty(property);
        System.err.println("Registering annotator " + customName +
            " with class " + customClassName);
        pool.register(customName, new AnnotatorFactory(inputProps, annotatorImplementation) {
          private static final long serialVersionUID = 1L;
          @Override
          public Annotator create() {
            return annotatorImplementation.custom(properties, property);
          }
          @Override
          public String additionalSignature() {
            // keep track of all relevant properties for this annotator here!
            // since we don't know what props they need, let's copy all
            // TODO: can we do better here? maybe signature() should be a method in the Annotator?
            StringBuilder os = new StringBuilder();
            for(Object key: properties.keySet()) {
              String skey = (String) key;
              os.append(skey + ":" + properties.getProperty(skey));
            }
            return os.toString();
          }
        });
      }
    }


    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        return annotatorImplementation.relations(properties);
      }

      @Override
      public String additionalSignature() {
        // keep track of all relevant properties for this annotator here!
        return "sup.relation.verbose:" +
        properties.getProperty("sup.relation.verbose",
                "false") +
        properties.getProperty("sup.relation.model",
                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);
      }
    });

    pool.register(STANFORD_SENTIMENT, new AnnotatorFactory(inputProps, annotatorImplementation) {
      private static final long serialVersionUID = 1L;
      @Override
      public Annotator create() {
        return annotatorImplementation.sentiment(properties, STANFORD_SENTIMENT);
      }

      @Override
      public String additionalSignature() {
        return "sentiment.model=" + inputProps.get("sentiment.model");
      }
    });

    //
    // add more annotators here!
    //
    return pool;
  }

  public static synchronized Annotator getExistingAnnotator(String name) {
    if(pool == null){
      System.err.println("ERROR: attempted to fetch annotator \"" + name + "\" before the annotator pool was created!");
      return null;
    }
    try {
      Annotator a =  pool.get(name);
      return a;
    } catch(IllegalArgumentException e) {
      System.err.println("ERROR: attempted to fetch annotator \"" + name + "\" but the annotator pool does not store any such type!");
      return null;
    }
  }

  @Override
  public void annotate(Annotation annotation) {
    super.annotate(annotation);
    List<CoreLabel> words = annotation.get(CoreAnnotations.TokensAnnotation.class);
    if (words != null) {
      numWords += words.size();
    }
  }

