
  protected static double[] smooth(List<double[]> toSmooth){
    double[] smoothed = new double[toSmooth.get(0).length];

    for(double[] thisArray:toSmooth){
      ArrayMath.pairwiseAddInPlace(smoothed,thisArray);
    }

    ArrayMath.multiplyInPlace(smoothed,1/((double) toSmooth.size() ));
    return smoothed;
  }


  private void initFiles() {
    if (outputIterationsToFile) {

      String fileName = getName() + ".output";
      String infoName = getName() + ".info";

      try {
        file = new PrintWriter(new FileOutputStream(fileName),true);
        infoFile = new PrintWriter(new FileOutputStream(infoName),true);
      }
      catch (IOException e) {
        System.err.println("Caught IOException outputting data to file: " + e.getMessage());
        System.exit(1);
      }
    }
  }


  public abstract Pair<Integer,Double> tune(Function function,double[] initial, long msPerTest);

  public double tuneDouble(edu.stanford.nlp.optimization.Function function, double[] initial, long msPerTest,PropertySetter<Double> ps,double lower,double upper){
  }

  public double tuneDouble(edu.stanford.nlp.optimization.Function function, double[] initial, long msPerTest,PropertySetter<Double> ps,double lower,double upper,double TOL){

    double[] xtest = new double[initial.length];
    this.maxTime = msPerTest;
    // check for stochastic derivatives
    if (!(function instanceof AbstractStochasticCachingDiffFunction)) {
      throw new UnsupportedOperationException();
    }
    AbstractStochasticCachingDiffFunction dfunction = (AbstractStochasticCachingDiffFunction) function;

    List<Pair<Double,Double>> res = new ArrayList<Pair<Double,Double>>();
    Pair<Double,Double> best = new Pair<Double,Double>(lower,Double.POSITIVE_INFINITY); //this is set to lower because the first it will always use the lower first, so it has to be best
    Pair<Double,Double> low = new Pair<Double,Double>(lower,Double.POSITIVE_INFINITY);
    Pair<Double,Double> high = new Pair<Double,Double>(upper,Double.POSITIVE_INFINITY);
    Pair<Double,Double> cur = new Pair<Double,Double>();
    Pair<Double,Double> tmp = new Pair<Double,Double>();

    List<Double> queue = new ArrayList<Double>();
    queue.add(lower);
    queue.add(upper);

    boolean  toContinue = true;
    this.numPasses = 10000;

    do{
      System.arraycopy(initial, 0, xtest, 0, initial.length);
      if(queue.size() != 0){
        cur.first = queue.remove(0);
      }else{
      }

      ps.set(cur.first() );

      System.err.println("");
      System.err.println("About to test with batch size:  " + bSize +
              "  gain: "  + gain + " and  " +
              ps.toString() + " set to  " + cur.first());

      xtest = this.minimize(function, 1e-100, xtest);

      if(Double.isNaN( xtest[0] ) ){
        cur.second = Double.POSITIVE_INFINITY;
      } else {
        cur.second = dfunction.valueAt(xtest);
      }

      if( cur.second() < best.second() ){

        copyPair(best,tmp);
        copyPair(cur,best);

        if(tmp.first() > best.first()){
          copyPair(tmp,high); // The old best is now the upper bound
        }else{
          copyPair(tmp,low);  // The old best is now the lower bound
        }
      } else if ( cur.first() < best.first() ){
        copyPair(cur,low);
      } else if( cur.first() > best.first()){
        copyPair(cur,high);
      }

      if( Math.abs( low.first() - high.first() ) < TOL   ) {
        toContinue = false;
      }

      res.add(new Pair<Double,Double>(cur.first(),cur.second()));

      System.err.println("");
      System.err.println("Final value is: " + nf.format(cur.second()));
      System.err.println("Optimal so far using " + ps.toString() + " is: "+ best.first() );
    } while(toContinue);


    //output the results to screen.
    System.err.println("-------------");
    System.err.println(" RESULTS          ");
    System.err.println(ps.getClass().toString());
    System.err.println("-------------");
    System.err.println("  val    ,    function after " + msPerTest + " ms");
    for(int i=0;i<res.size();i++ ){
      System.err.println(res.get(i).first() + "    ,    " + res.get(i).second() );
     }
    System.err.println("");
    System.err.println("");

    return best.first();

  }

  private static void copyPair(Pair<Double,Double> from, Pair<Double,Double> to) {
    to.first = from.first();
    to.second = from.second();
  }


  private class setGain implements PropertySetter<Double>{
    StochasticMinimizer<T> parent = null;

    public setGain(StochasticMinimizer<T> min) {
      parent = min;
    }

    public void set(Double in) {
      gain = in ;
    }
  }


  public double tuneGain(Function function, double[] initial, long msPerTest, double lower, double upper){

    return tuneDouble(function,initial,msPerTest,new setGain(this),lower,upper);
  }


  // [cdm 2012: The version that used to be here was clearly buggy;
  // I changed it a little, but didn't test it. It's now more correct, but
  // I think it is still conceptually faulty, since it will keep growing the
  // batch size so long as any minute improvement in the function value is
  // obtained, whereas the whole point of using a small batch is to get speed
  // at the cost of small losses.]
  public int tuneBatch(Function function, double[] initial, long msPerTest, int bStart) {

    double[] xTest = new double[initial.length];
    int bOpt = 0;
    double min = Double.POSITIVE_INFINITY;
    this.maxTime = msPerTest;
    double prev = Double.POSITIVE_INFINITY;

    // check for stochastic derivatives
    if (!(function instanceof AbstractStochasticCachingDiffFunction)) {
      throw new UnsupportedOperationException();
    }
    AbstractStochasticCachingDiffFunction dFunction = (AbstractStochasticCachingDiffFunction) function;

    int b = bStart;
    boolean  toContinue = true;

    do {
      System.arraycopy(initial, 0, xTest, 0, initial.length);
      System.err.println("");
      System.err.println("Testing with batch size:  " + b );
      bSize = b;
      shutUp();
      this.minimize(function, 1e-5, xTest);
      double result = dFunction.valueAt(xTest);

      if (result < min) {
        min = result;
        bOpt = bSize;
        prev = result;
      } else if(result < prev) {
        prev = result;
      } else if (result > prev) {
        toContinue = false;
      }

      System.err.println("");
      System.err.println("Final value is: " + nf.format(result));
      System.err.println("Optimal so far is:  batch size: " + bOpt );
    } while (toContinue);

    return bOpt;
  }

  public Pair<Integer,Double> tune(Function function, double[] initial, long msPerTest,List<Integer> batchSizes, List<Double> gains){

    double[] xtest = new double[initial.length];
    int bOpt = 0;
    double gOpt = 0.0;
    double min = Double.POSITIVE_INFINITY;

    double[][] results = new double[batchSizes.size()][gains.size()];

    this.maxTime = msPerTest;

    for( int b=0;b<batchSizes.size();b++){
      for(int g=0;g<gains.size();g++){
        System.arraycopy(initial, 0, xtest, 0, initial.length);
        bSize = batchSizes.get(b);
        gain = gains.get(g);
        System.err.println("");
        System.err.println("Testing with batch size: " + bSize + "    gain:  " + nf.format(gain) );
        this.quiet = true;
        this.minimize(function, 1e-100, xtest);
        results[b][g] = function.valueAt(xtest);

        if( results[b][g] < min ){
          min = results[b][g];
          bOpt = bSize;
          gOpt = gain;
        }

        System.err.println("");
        System.err.println("Final value is: " + nf.format(results[b][g]));
        System.err.println("Optimal so far is:  batch size: " + bOpt + "   gain:  " + nf.format(gOpt) );

      }
    }

    return new Pair<Integer,Double>(bOpt,gOpt);
  }


  //This can be filled if an extending class needs to initialize things.
  protected void init(AbstractStochasticCachingDiffFunction func){
  }


  private void doEvaluation(double[] x) {
    // Evaluate solution
    if (evaluators == null) return;
    for (Evaluator eval:evaluators) {
      sayln("  Evaluating: " + eval.toString());
      eval.evaluate(x);
    }
  }

  public double[] minimize(Function function, double functionTolerance, double[] initial) {
    return minimize(function, functionTolerance, initial, -1);
  }


  public double[] minimize(Function function, double functionTolerance, double[] initial, int maxIterations) {

    // check for stochastic derivatives
    if (!(function instanceof AbstractStochasticCachingDiffFunction)) {
      throw new UnsupportedOperationException();
    }
    AbstractStochasticCachingDiffFunction dfunction = (AbstractStochasticCachingDiffFunction) function;

    dfunction.method = StochasticCalculateMethods.GradientOnly;

