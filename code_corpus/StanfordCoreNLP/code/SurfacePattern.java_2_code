
public class SurfacePattern implements Serializable, Comparable<SurfacePattern> {

  public static enum Genre {
    PREV, NEXT, PREVNEXT
  };

  private static final long serialVersionUID = 1L;

  protected String[] prevContext;
  protected String[] nextContext;
  // String prevContextStr = "", nextContextStr = "";
  protected PatternToken token;
  // protected String[] originalPrev;
  // protected String[] originalNext;
  // protected String originalPrevStr = "";
  // protected String originalNextStr = "";
  // protected String toString;
  protected int hashcode;
  protected Genre genre;

  public Genre getGenre() {
    return genre;
  }

  public void setGenre(Genre genre) {
    this.genre = genre;
  }

  public static boolean insertModifierWildcard = false;

  public SurfacePattern(String[] prevContext, PatternToken token, String[] nextContext, Genre genre) {
    // String[] originalPrev, String[] originalNext, Genre genre) {
    prevContext = trim(prevContext);
    nextContext = trim(nextContext);
    this.setPrevContext(prevContext);
    this.setNextContext(nextContext);
    //
    // if (prevContext != null)
    // prevContextStr = StringUtils.join(prevContext, " ");
    //
    // if (nextContext != null)
    // nextContextStr = StringUtils.join(nextContext, " ");

    this.setToken(token);
    // this.setOriginalPrev(originalPrev);
    // this.setOriginalNext(originalNext);
    this.genre = genre;

    hashcode = toString().hashCode();

  }

  String[] trim(String[] p) {

    if (p == null)
      return null;

    for (int i = 0; i < p.length; i++) {
      p[i] = p[i].trim();
    }
    return p;
  }

  public static String getContextStr(CoreLabel tokenj, boolean useLemmaContextTokens, boolean lowerCaseContext) {
    String str = "";

    if (useLemmaContextTokens) {
      String tok = tokenj.lemma();
      if (lowerCaseContext)
        tok = tok.toLowerCase();
      str = "[{lemma:/" + Pattern.quote(tok)+ "/}] ";
      //str = "[{lemma:/\\Q" + tok.replaceAll("/", "\\\\/") + "\\E/}] ";
    } else {
      String tok = tokenj.word();
      if (lowerCaseContext)
        tok = tok.toLowerCase();
      str = "[{word:/" + Pattern.quote(tok) + "/}] ";
      //str = "[{word:/\\Q" + tok.replaceAll("/", "\\\\/") + "\\E/}] ";

    }
    return str;
  }

  public static String getContextStr(String w) {
    String str = "[/" + Pattern.quote(w) + "/] ";
    //String str = "[/\\Q" + w.replaceAll("/", "\\\\/") + "\\E/] ";
    return str;
  }

  public String toString(List<String> notAllowedClasses) {
    String prevContextStr = "", nextContextStr = "";
    if (prevContext != null)
      prevContextStr = StringUtils.join(prevContext, " ");

    if (nextContext != null)
      nextContextStr = StringUtils.join(nextContext, " ");

    return (prevContextStr + " " + getToken().getTokenStr(notAllowedClasses) + " " + nextContextStr).trim();
  }

  public String toString(String morePreviousPattern, String moreNextPattern, List<String> notAllowedClasses) {

    String prevContextStr = "", nextContextStr = "";
    if (prevContext != null)
      prevContextStr = StringUtils.join(prevContext, " ");

    if (nextContext != null)
      nextContextStr = StringUtils.join(nextContext, " ");

    return (prevContextStr + " " + morePreviousPattern + " " + getToken().getTokenStr(notAllowedClasses) + " " + moreNextPattern + " " + nextContextStr)
        .trim();
  }

  public String getPrevContextStr() {
    String prevContextStr = "";
    if (prevContext != null)
      prevContextStr = StringUtils.join(prevContext, " ");
    return prevContextStr;
  }

  public String getNextContextStr() {
    String nextContextStr = "";
    if (nextContext != null)
      nextContextStr = StringUtils.join(nextContext, " ");
    return nextContextStr;
  }

  // returns 0 is exactly equal, Integer.MAX_VALUE if the contexts are not same.
  // If contexts are same : it returns (objects restrictions on the token minus
  // p's restrictions on the token). So if returns negative then p has more
  // restrictions.
  public int equalContext(SurfacePattern p) {
    if (p.equals(this))
      return 0;

    if (Arrays.equals(this.prevContext, p.getPrevContext()) && Arrays.equals(this.nextContext, p.getNextContext())) {
      int this_restriction = 0, p_restriction = 0;

      if (this.getToken().useTag)
        this_restriction++;
      if (p.getToken().useTag)
        p_restriction++;

      if (this.getToken().useNER)
        this_restriction++;
      if (p.getToken().useNER)
        p_restriction++;

      if (this.getToken().useTargetParserParentRestriction)
        this_restriction++;
      if (p.getToken().useTargetParserParentRestriction)
        p_restriction++;

      this_restriction -= this.getToken().numWordsCompound;
      p_restriction -= this.getToken().numWordsCompound;
      return this_restriction - p_restriction;
    }
    return Integer.MAX_VALUE;
  }

  @Override
  public boolean equals(Object b) {
    if (!(b instanceof SurfacePattern))
      return false;
    SurfacePattern p = (SurfacePattern) b;
    // if (toString().equals(p.toString()))

    if (!token.equals(p.token))
      return false;

    if ((this.prevContext == null && p.prevContext != null) || (this.prevContext != null && p.prevContext == null))
      return false;

    if ((this.nextContext == null && p.nextContext != null) || (this.nextContext != null && p.nextContext == null))
      return false;

    if (this.prevContext != null && !Arrays.equals(this.prevContext, p.prevContext))
      return false;

    if (this.nextContext != null && !Arrays.equals(this.nextContext, p.nextContext))
      return false;

    return true;
  }

  @Override
  public int hashCode() {
    return hashcode;
  }

  @Override
  public String toString() {
    return toString(null);
  }

  public String toStringToWrite() {

    return getPrevContextStr() + "##" + getToken().toStringToWrite() + "##" + getNextContextStr();
  }

  public String[] getSimplerTokensPrev() {
    return getSimplerTokens(prevContext);
  }

  public String[] getSimplerTokensNext() {
    return getSimplerTokens(nextContext);
  }

      + Pattern.quote("]"));

  public String[] getSimplerTokens(String[] p) {
    if (p == null)
      return null;

    String[] sim = new String[p.length];
    for (int i = 0; i < p.length; i++) {

      assert p[i] != null : "How is the any one " + Arrays.toString(p) + " null!";

      if (p1 == null)
        throw new RuntimeException("how is p1 null");

      Matcher m = p1.matcher(p[i]);

      if (m.matches()) {
        sim[i] = m.group(2);
      } else {
        Matcher m2 = p2.matcher(p[i]);
        if (m2.matches()) {
          sim[i] = m2.group(2);
        } else if (p[i].startsWith("$FILLER"))
          sim[i] = "FW";
        else if (p[i].startsWith("$STOP"))
          sim[i] = "SW";
        else
          throw new RuntimeException("Cannot understand " + p[i]);
      }
    }
    return sim;

  }

  public String toStringSimple() {

    String[] simprev = getSimplerTokensPrev();
    String[] simnext = getSimplerTokensNext();
    String prevstr = simprev == null ? "" : StringUtils.join(simprev, " ");
    String nextstr = simnext == null ? "" : StringUtils.join(simnext, " ");

    String sim = prevstr.trim() + " <b>" + getToken().toStringToWrite() + "</b> " + nextstr.trim();
    return sim;
  }

  public String[] getPrevContext() {
    return prevContext;
  }

  public void setPrevContext(String[] prevContext) {
    this.prevContext = prevContext;
  }

  public String[] getNextContext() {
    return nextContext;
  }

  public void setNextContext(String[] nextContext) {
    this.nextContext = nextContext;
  }

  public PatternToken getToken() {
    return token;
  }

  public void setToken(PatternToken token) {
    this.token = token;
  }

  // private String getOriginalPrevStr() {
  // String originalPrevStr = "";
  // if (originalPrev != null)
  // originalPrevStr = StringUtils.join(originalPrev, " ");
  //
  // return originalPrevStr;
  // }

  // public void setOriginalPrevStr(String originalPrevStr) {
  // this.originalPrevStr = originalPrevStr;
  // }

  // public String getOriginalNextStr() {
  // String originalNextStr = "";
  // if (originalNext != null)
  // originalNextStr = StringUtils.join(originalNext, " ");
  // return originalNextStr;
  // }

  // public void setOriginalNextStr(String originalNextStr) {
  // this.originalNextStr = originalNextStr;
  // }

  // public String[] getOriginalPrev() {
  // return originalPrev;
  // }
  //
  // public void setOriginalPrev(String[] originalPrev) {
  // this.originalPrev = originalPrev;
  // }
  //
  // public String[] getOriginalNext() {
  // return originalNext;
  // }
  //
  // public void setOriginalNext(String[] originalNext) {
  // this.originalNext = originalNext;
  // }

  public static boolean sameGenre(SurfacePattern p1, SurfacePattern p2) {
    return p1.getGenre().equals(p2.getGenre());
  }

