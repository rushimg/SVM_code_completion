    String openingTag;

    private void outputTextAndTag(String qName, Attributes attributes, boolean close) {
      // If we're not already in an element to be transformed, first
      // echo the previous text...
      outWriter.print(XMLUtils.escapeXML(textToBeTransformed.toString()));
      textToBeTransformed = new StringBuffer();
      
      // ... then echo the new tag to outStream 
      outWriter.print('<');
      if (close) {
        outWriter.print('/');
      }
      outWriter.print(qName);
      if (attributes != null) {
        for (int i = 0; i < attributes.getLength(); i++) {
          outWriter.print(' ');
          outWriter.print(attributes.getQName(i));
          outWriter.print("=\"");
          outWriter.print(XMLUtils.escapeXML(attributes.getValue(i)));
          outWriter.print('"');
        }
      }
      outWriter.print(">\n");
    }

    @Override
    public void endDocument() {
      // Theoretically, there shouldn't be anything in the buffer after
      // the last closing tag, but if there is, it's probably better to
      // echo it than ignore it
      outWriter.print(XMLUtils.escapeXML(textToBeTransformed.toString()));
      // we need to flush because there are no other ways we
      // explicitely flush
      outWriter.flush();
    }
    
    // Called at the beginning of each element.  If the tag is on the
    // designated list, set flag to remember that we're in an element
    // to be transformed.  In either case, echo tag.
    @Override
    public void startElement(String uri, String localName, String qName, 
                             Attributes attributes) throws SAXException {
      //System.err.println("start element " + qName);
      
      if (depth == 0) {
        outputTextAndTag(qName, attributes, false);
      }
      
      if (elementsToBeTransformed.contains(qName)) {
        if (depth == 0) {
          openingTag = qName;
        }
        ++depth;
      }
    }

    // Called at the end of each element.  If the tag is on the
    // designated list, apply the designated {@link Function
    // <code>Function</code>} to the accumulated text and echo the the
    // result.  In either case, echo the closing tag.
    @Override
    public void endElement(String uri, String localName, String qName) 
      throws SAXException 
    {
      //System.err.println("end element " + qName + "; function is " + function.getClass());
      //System.err.println("elementsToBeTransformed is " + elementsToBeTransformed);
      //System.err.println("textToBeTransformed is " + textToBeTransformed);
      
      if (depth == 0) {
        outputTextAndTag(qName, null, true);
      } else {
        if (elementsToBeTransformed.contains(qName)) {
          --depth;
          if (depth == 0) {
            String text = textToBeTransformed.toString().trim();
            // factored out so subclasses can handle the text differently
            processText(text);
            textToBeTransformed = new StringBuffer();
            outWriter.print("</" + openingTag + ">\n");
          }
        }
        // when we're inside a block to be transformed, we ignore
        // elements that don't end the block.
      }
    }

    public void processText(String text) {
      if (text.length() > 0) {
        text = function.apply(text).toString();
        outWriter.print(XMLUtils.escapeXML(text));
        outWriter.print('\n');
      }
    }
    

    // Accumulate characters in buffer of text to be transformed
    // (SAX may call this after each line break)
    @Override
    public void characters(char[] buf, int offset, int len) throws SAXException {
      // System.err.println("characters |" + new String(buf, offset, len) + "|");
      textToBeTransformed.append(buf, offset, len);
    }
  } // end static class SAXInterface


