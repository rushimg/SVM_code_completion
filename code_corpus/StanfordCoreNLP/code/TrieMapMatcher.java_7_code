  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, MatchCostFunction<K,V> costFunction,
                                                   double maxCost, int n, boolean multimatch, boolean keepAlignments) {
    if (root.isEmpty()) return null;
    int extra = 3;
    // Find the closest n options to the key in the trie based on the given cost function for substitution
    // matches[i][j] stores the top n partial matches for i elements from the target
    //   and j elements from the partial matches from trie keys

    // At any time, we only keep track of the last two rows
    // (prevMatches (matches[i-1][j]), curMatches (matches[i][j]) that we are working on
    MatchQueue<K,V> best = new MatchQueue<K, V>(n, maxCost);
    List<PartialApproxMatch<K,V>>[] prevMatches = null;
    List<PartialApproxMatch<K,V>>[] curMatches;
    for (int i = 0; i <= target.size(); i++) {
      curMatches = new List[target.size()+1+extra];
      for (int j = 0; j <= target.size()+extra; j++) {
        if (j > 0) {
          boolean complete = (i == target.size());
          // Try to pick best match from trie
          K t = (i > 0 && i <= target.size())? target.get(i-1):null;
          // Look at the top n choices we saved away and pick n new options
          MatchQueue<K,V> queue = (multimatch)? new MultiMatchQueue<K, V>(n, maxCost):new MatchQueue<K, V>(n, maxCost);
          if (i > 0) {
            for (PartialApproxMatch<K,V> pam:prevMatches[j-1]) {
              if (pam.trie != null) {
                if (pam.trie.children != null) {
                  for (K k:pam.trie.children.keySet()) {
                    addToQueue(queue, best, costFunction, pam, t, k, multimatch, complete);
                  }
                }
              }
            }
          }
          for (PartialApproxMatch<K,V> pam:curMatches[j-1]) {
            if (pam.trie != null) {
              if (pam.trie.children != null) {
                for (K k:pam.trie.children.keySet()) {
                  addToQueue(queue, best, costFunction, pam, null, k, multimatch, complete);
                }
              }
            }
          }
          if (i > 0) {
            for (PartialApproxMatch<K,V> pam:prevMatches[j]) {
              addToQueue(queue, best, costFunction, pam, t, null, multimatch, complete);
            }
          }
          curMatches[j] = queue.toSortedList();
        } else {
          curMatches[0] = new ArrayList<PartialApproxMatch<K,V>>();
          if (i > 0) {
            K t = (i < target.size())? target.get(i-1):null;
            for (PartialApproxMatch<K,V> pam:prevMatches[0]) {
              PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, costFunction.cost(t, null, pam.getMatchedLength()), t, null);
              if (npam.cost <= maxCost) {
                curMatches[0].add(npam);
              }
            }
          } else {
            curMatches[0].add(new PartialApproxMatch<K,V>(0, root, keepAlignments? target.size():0));
          }
        }
//        System.out.println("i=" + i + ",j=" + j + "," + matches[i][j]);
      }
      prevMatches = curMatches;
    }
    // Get the best matches
    List<ApproxMatch<K,V>> res = new ArrayList<ApproxMatch<K,V>>();
    for (PartialApproxMatch<K,V> m:best.toSortedList()) {
      res.add(m.toApproxMatch());
    }
    return res;
  }

