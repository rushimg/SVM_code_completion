/**
 * <p>
 * TokensRegexNERAnnotator labels tokens with types based on a simple manual mapping from
 * regular expressions to the types of the entities they are meant to describe.
 * The user provides a file formatted as follows:
 * <pre>
 *    regex1    TYPE    overwritableType1,Type2...    priority
 *    regex2    TYPE    overwritableType1,Type2...    priority
 *    ...
 * </pre>
 * where each argument is tab-separated, and the last two arguments are optional. Several regexes can be
 * associated with a single type. In the case where multiple regexes match a phrase, the priority ranking
 * is used to choose between the possible types. When the priority is the same, then longer matches are favored.
 * This classifier is designed to be used as part of a full
 * NER system to label entities that don't fall into the usual NER categories. It only records the label
 * if the token has not already been NER-annotated, or it has been annotated but the NER-type has been
 * designated overwritable (the third argument).
 * </p>
 *
 * <p>
 * The first column regex may follow one of two formats:
 * <ol>
 * <li> A TokensRegex expression (marked by starting with "( " and ending with " )".
 *      See {@link TokenSequencePattern} for TokensRegex syntax.
 *    <br/><em>Example</em>: <code>( /University/ /of/ [ {ner:LOCATION} ] )    SCHOOL</code>
 * </li>
 * <li> a sequence of regex, each separated by whitespace (matching "\s+").
 *    <br/><em>Example</em>: <code>Stanford    SCHOOL</code>
 *    <br/>
 *    The regex will match if the successive regex match a sequence of tokens in the input.
 *    Spaces can only be used to separate regular expression tokens; within tokens \s or similar non-space
 *    representations need to be used instead.
 *    <br/>
 *    Notes: Following Java regex conventions, some characters in the file need to be escaped. Only a single
 *    backslash should be used though, as these are not String literals. The input to RegexNER will have
 *    already been tokenized.  So, for example, with our usual English tokenization, things like genitives
 *    and commas at the end of words will be separated in the input and matched as a separate token.</li>
 * </ol>
 * </p>
 *
 * <p>
 * This annotator is similar to {@link RegexNERAnnotator} but uses TokensRegex as the underlying library for matching
 * regular expressions.  This allows for more flexibility in the types of expressions matched as well as utilizing
 * any optimization that is included in the TokensRegex library.
 * </p>
 * <p>
 * Main differences from {@link RegexNERAnnotator}:
 * <ul>
 *   <li>Supports both TokensRegex patterns and patterns over the text of the tokens</li>
 *   <li>When NER annotation can be overwritten based on the original NER labels.  The rules for when the new NER labels are used
 *       are given below:
 *       <br/>If the found expression overlaps with a previous NER phrase, then the NER labels are not replaced.
 *       <br/>  <em>Example</em>: Old NER phrase: <code>The ABC Company</code>, Found Phrase: <code>ABC => </code> Old NER labels are not replaced.
 *       <br/>If the found expression has inconsistent NER tags among the tokens, then the NER labels are replaced.
 *       <br/>  <em>Example</em>: Old NER phrase: <code>The/O ABC/MISC Company/ORG => The/ORG ABC/ORG Company/ORG</code>
 *   </li>
 *   <li>How <code>validpospattern</code> is handled for POS tags is specified by <code>PosMatchType</code></li>
 *   <li>By default, there is no <code>validPosPattern</code></li>
 *   <li>By default, both O and MISC is always replaced</li>
 * </ul>
 * </p>
 * <p>
 *   Configuration:
 * <table>
 *   <tr><th>Field</th><th>Description</th><th>Default</th></tr>
 *   <tr><td><code>mapping</code></td><td>Comma separated list of mapping files to use </td>
 *      <td><code>edu/stanford/nlp/models/regexner/type_map_clean</code></td>
 *   </tr>
 *   <tr><td><code>backgroundSymbol</code></td><td>Comma separated list of NER labels to always replace</td>
 *      <td><code>O,MISC</code></td></tr>
 *   <tr><td><code>posmatchtype</code></td>
 *     <td>How should <code>validpospattern</code> be used to match the POS of the tokens.
 *         <code>MATCH_ALL_TOKENS</code> - All tokens has to match.<br/>
 *         <code>MATCH_AT_LEAST_ONE_TOKEN</code> - At least one token has to match.<br/>
 *         <code>MATCH_ONE_TOKEN_PHRASE_ONLY</code> - Only has to match for one token phrases.<br/>
 *      </td>
 *      <td><code>MATCH_AT_LEAST_ONE_TOKEN</code></td>
 *   </tr>
 *   <tr><td><code>validpospattern</code></td><td>Regular expression pattern for matching POS tags.</td>
 *      <td><code></code></td>
 *   </tr>
 *   <tr><td><code>noDefaultOverwriteLabels</code></td>
 *      <td>Comma separated list of output types for which default NER labels are not overwritten.
 *          For these types, only if the matched expression has NER type matching the
 *          specified overwriteableType for the regex will the NER type be overwritten.</td>
 *      <td><code></code></td></tr>
 *   <tr><td><code>ignoreCase</code></td><td>If true, case is ignored</td></td>
 *      <td><code>false</code></td></tr>
 *   <tr><td><code>verbose</code></td><td>If true, turns on extra debugging messages.</td>
 *      <td><code>false</code></td></tr>
 * </table>
 * </p>
 *
 * @author Angel Chang
 */
