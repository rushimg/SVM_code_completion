/**
 * The abstract class <code>Tree</code> is used to collect all of the
 * tree types, and acts as a generic extendable type.  This is the
 * standard implementation of inheritance-based polymorphism.
 * All <code>Tree</code> objects support accessors for their children (a
 * <code>Tree[]</code>), their label (a <code>Label</code>), and their
 * score (a <code>double</code>).  However, different concrete
 * implementations may or may not include the latter two, in which
 * case a default value is returned.  The class Tree defines no data
 * fields.  The two abstract methods that must be implemented are:
 * <code>children()</code>, and <code>treeFactory()</code>.  Notes
 * that <code>setChildren(Tree[])</code> is now an optional
 * operation, whereas it was previously required to be
 * implemented. There is now support for finding the parent of a
 * tree.  This may be done by search from a tree root, or via a
 * directly stored parent.  The <code>Tree</code> class now
 * implements the <code>Collection</code> interface: in terms of
 * this, each <i>node</i> of the tree is an element of the
 * collection; hence one can explore the tree by using the methods of
 * this interface.  A <code>Tree</code> is regarded as a read-only
 * <code>Collection</code> (even though the <code>Tree</code> class
 * has various methods that modify trees).  Moreover, the
 * implementation is <i>not</i> thread-safe: no attempt is made to
 * detect and report concurrent modifications.
 *
 * @author Christopher Manning
 * @author Dan Klein
 * @author Sarah Spikes (sdspikes@cs.stanford.edu) - filled in types
 */
