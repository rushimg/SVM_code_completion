/**
 * A TregexPattern is a <code>tgrep</code>-type pattern for matching tree
 * node configurations.  Unlike <code>tgrep</code> or <code>tgrep2</code>but like Unix
 * <code>grep</code>, there is no pre-indexing of the data to be searched.
 * Rather there is a linear scan through the trees where matches are sought.
 * As a result, matching is slower, but a TregexPattern can be applied
 * to an arbitrary set of trees at runtime in a processing pipeline.
 *
 * <p> TregexPattern instances can be matched against instances of the {@link Tree} class.
 * The {@link #main} method can be used to find matching nodes of a treebank from the command line.
 *
 * <p>
 * Currently supported node-node relations and their symbols:
 * <p>
 * <table border = "1">
 * <tr><th>Symbol<th>Meaning
 * <tr><td>A &lt;&lt; B <td>A dominates B
 * <tr><td>A &gt;&gt; B <td>A is dominated by B
 * <tr><td>A &lt; B <td>A immediately dominates B
 * <tr><td>A &gt; B <td>A is immediately dominated by B
 * <tr><td>A &#36; B <td>A is a sister of B (and not equal to B)
 * <tr><td>A .. B <td>A precedes B
 * <tr><td>A . B <td>A immediately precedes B
 * <tr><td>A ,, B <td>A follows B
 * <tr><td>A , B <td>A immediately follows B
 * <tr><td>A &lt;&lt;, B <td>B is a leftmost descendant of A
 * <tr><td>A &lt;&lt;- B <td>B is a rightmost descendant of A
 * <tr><td>A &gt;&gt;, B <td>A is a leftmost descendant of B
 * <tr><td>A &gt;&gt;- B <td>A is a rightmost descendant of B
 * <tr><td>A &lt;, B <td>B is the first child of A
 * <tr><td>A &gt;, B <td>A is the first child of B
 * <tr><td>A &lt;- B <td>B is the last child of A
 * <tr><td>A &gt;- B <td>A is the last child of B
 * <tr><td>A &lt;` B <td>B is the last child of A
 * <tr><td>A &gt;` B <td>A is the last child of B
 * <tr><td>A &lt;i B <td>B is the ith child of A (i > 0)
 * <tr><td>A &gt;i B <td>A is the ith child of B (i > 0)
 * <tr><td>A &lt;-i B <td>B is the ith-to-last child of A (i > 0)
 * <tr><td>A &gt;-i B <td>A is the ith-to-last child of B (i > 0)
 * <tr><td>A &lt;: B <td>B is the only child of A
 * <tr><td>A &gt;: B <td>A is the only child of B
 * <tr><td>A &lt;&lt;: B <td>A dominates B via an unbroken chain (length > 0) of unary local trees.
 * <tr><td>A &gt;&gt;: B <td>A is dominated by B via an unbroken chain (length > 0) of unary local trees.
 * <tr><td>A &#36;++ B <td>A is a left sister of B (same as &#36;.. for context-free trees)
 * <tr><td>A &#36;-- B <td>A is a right sister of B (same as &#36;,, for context-free trees)
 * <tr><td>A &#36;+ B <td>A is the immediate left sister of B (same as &#36;. for context-free trees)
 * <tr><td>A &#36;- B <td>A is the immediate right sister of B (same as &#36;, for context-free trees)
 * <tr><td>A &#36;.. B <td>A is a sister of B and precedes B
 * <tr><td>A &#36;,, B <td>A is a sister of B and follows B
 * <tr><td>A &#36;. B <td>A is a sister of B and immediately precedes B
 * <tr><td>A &#36;, B <td>A is a sister of B and immediately follows B
 * <tr><td>A &lt;+(C) B <td>A dominates B via an unbroken chain of (zero or more) nodes matching description C
 * <tr><td>A &gt;+(C) B <td>A is dominated by B via an unbroken chain of (zero or more) nodes matching description C
 * <tr><td>A .+(C) B <td>A precedes B via an unbroken chain of (zero or more) nodes matching description C
 * <tr><td>A ,+(C) B <td>A follows B via an unbroken chain of (zero or more) nodes matching description C
 * <tr><td>A &lt;&lt;&#35; B <td>B is a head of phrase A
 * <tr><td>A &gt;&gt;&#35; B <td>A is a head of phrase B
 * <tr><td>A &lt;&#35; B <td>B is the immediate head of phrase A
 * <tr><td>A &gt;&#35; B <td>A is the immediate head of phrase B
 * <tr><td>A == B <td>A and B are the same node
 * <tr><td>A &lt;= B <td>A and B are the same node or A is the parent of B
 * <tr><td>A : B<td>[this is a pattern-segmenting operator that places no constraints on the relationship between A and B]
 * <tr><td>A &lt;... { B ; C ; ... }<td>A has exactly B, C, etc as its subtree, with no other children.
 * </table>
 * <p> Label descriptions can be literal strings, which much match labels
 * exactly, or regular expressions in regular expression bars: /regex/.
 * Literal string matching proceeds as String equality.
 * In order to prevent ambiguity with other Tregex symbols, ASCII symbols are
 * not allowed in literal strings, and they cannot begin with ASCII digits.
 * (That is literals can be standard "identifiers" matching
 * [a-zA-Z]([a-zA-Z0-9_-])* but also may include letters from other alphabets.)
 * If you want to use other symbols, you can do so by using a regular
 * expression instead of a literal string.
 * A disjunctive list of literal strings can be given separated by '|'.
 * The special string '__' (two underscores) can be used to match any
 * node.  (WARNING!!  Use of the '__' node description may seriously
 * slow down search.)  If a label description is preceded by '@', the
 * label will match any node whose <em>basicCategory</em> matches the
 * description.  <emph>NB: A single '@' thus scopes over a disjunction
 * specified by '|': @NP|VP means things with basic category NP or VP.
 * </emph> The basicCategory is defined according to a Function
 * mapping Strings to Strings, as provided by
 * {@link edu.stanford.nlp.trees.AbstractTreebankLanguagePack#getBasicCategoryFunction()}.
 * Label description regular expressions are matched as <code>find()</code>,
 * as in Perl/tgrep;
 * you need to use <code>^</code> or <code>$</code> to constrain matches to
 * the ends of strings.
 * <p/>
 * In a chain of relations, all relations are relative to the first node in
 * the chain. For example, <code> (S &lt; VP &lt; NP) </code> means
 * "an S over a VP and also over an NP".
 * If instead what you want is an S above a VP above an NP, you should write
 * "<code>S &lt; (VP &lt; NP)</code>".
 * <p> Nodes can be grouped using parentheses '(' and ')'
 * as in <code> S &lt; (NP $++ VP) </code> to match an S
 * over an NP, where the NP has a VP as a right sister.
 *
 * <h3>Notes on relations</h3>
 *
 * <p>
 * Node <code>B</code> "follows" node <code>A</code> if <code>B</code>
 * or one of its ancestors is a right sibling of <code>A</code> or one
 * of its ancestors.  Node <code>B</code> "immediately follows" node
 * <code>A</code> if <code>B</code> follows <code>A</code> and there
 * is no node <code>C</code> such that <code>B</code> follows
 * <code>C</code> and <code>C</code> follows <code>A</code>.
 *
 * <p>
 * Node <code>A</code> dominates <code>B</code> through an unbroken
 * chain of unary local trees only if <code>A</code> is also
 * unary. <code>(A (B))</code> is a valid example that matches <code>A
 * &lt;&lt;: B</code>
 *
 * <p>
 * When specifying that nodes are dominated via an unbroken chain of
 * nodes matching a description <code>C</code>, the description
 * <code>C</code> cannot be a full Tregex expression, but only an
 * expression specifying the name of the node.  Negation of this
 * description is allowed.
 *
 * <p>
 * == has the same precedence as the other relations, so the expression
 * <code>A &lt;&lt; B == A &lt;&lt; C</code> associates as
 * <code>(((A &lt;&lt; B) == A) &lt;&lt; C)</code>, not as
 * <code>((A &lt;&lt; B) == (A &lt;&lt; C))</code>.  (Both expressions are
 * equivalent, of course, but this is just an example.)
 *
 * <h3>Boolean relational operators</h3>
 *
 * <p> Relations can be combined using the '&' and '|' operators,
 * negated with the '!' operator, and made optional with the '?' operator.
 * Thus <code> (NP < NN | < NNS) </code> will match an NP node dominating either
 * an NN or an NNS.  <code> (NP > S & $++ VP) </code> matches an NP that
 * is both under an S and has a VP as a right sister.
 * <p>
 * Expressions stop evaluating as soon as the result is known.  For
 * example, if the pattern is <code>NP=a | NNP=b</code> and the NP
 * matches, then variable <code>b</code> will not be assigned even if
 * there is an NNP in the tree.
 *
 * <p> Relations can be grouped using brackets '[' and ']'.  So the
 * expression
 *
 * <blockquote>
 * <code> NP [< NN | < NNS] & > S </code>
 * </blockquote>
 *
 *  matches an NP that (1) dominates either an NN or an NNS, and (2) is under an S.  Without
 * brackets, &amp; takes precedence over |, and equivalent operators are
 * left-associative.  Also note that &amp; is the default combining operator if the
 * operator is omitted in a chain of relations, so that the two patterns are equivalent:
 *
 * <blockquote>
 * <code> (S < VP < NP) </code><br>
 * <code> (S < VP & < NP) </code>
 * </blockquote>
 *
 * As another example, <code> (VP < VV | < NP % NP)
 * </code> can be written explicitly as <code> (VP [< VV | [< NP & % NP] ] )
 * </code>
 *
 * <p> Relations can be negated with the '!' operator, in which case the
 * expression will match only if there is no node satisfying the relation.
 * For example <code> (NP !< NNP) </code> matches only NPs not dominating
 * an NNP.  Label descriptions can also be negated with '!': (NP < !NNP|NNS) matches
 * NPs dominating some node that is not an NNP or an NNS.
 * <p> Relations can be made optional with the '?' operator.  This way the
 * expression will match even if the optional relation is not satisfied.  This is useful when used together
 *  with node naming (see below).
 *
 * <p><h3>Basic Categories</h3>
 *
 * <p> In order to consider only the "basic category" of a tree label,
 * i.e. to ignore functional tags or other annotations on the label,
 * prefix that node's description with the &#64; symbol.  For example
 * <code> (@NP < @/NN.?/) </code>  This can only be used for individual nodes;
 * if you want all nodes to use the basic category, it would be more efficient
 * to use a {@link edu.stanford.nlp.trees.TreeNormalizer} to remove functional
 * tags before passing the tree to the TregexPattern.
 *
 * <p><h3>Segmenting patterns</h3>
 *
 * <p>The ":" operator allows you to segment a pattern into two pieces.  This can simplify your pattern writing.  For example,
 * the pattern
 *
 * <blockquote>
 *   S : NP
 * </blockquote>
 *
 * matches only those S nodes in trees that also have an NP node.
 *
 * <p><h3>Naming nodes</h3>
 *
 * <p> Nodes can be given names (a.k.a. handles) using '='.  A named node will be stored in a
 * map that maps names to nodes so that if a match is found, the node
 * corresponding to the named node can be extracted from the map.  For
 * example <code> (NP < NNP=name) </code> will match an NP dominating an NNP
 * and after a match is found, the map can be queried with the
 * name to retreived the matched node using {@link TregexMatcher#getNode(String o)}
 * with (String) argument "name" (<it>not</it> "=name").
 * Note that you are not allowed to name a node that is under the scope of a negation operator (the semantics would
 * be unclear, since you can't store a node that never gets matched to).
 * Trying to do so will cause a {@link TregexParseException} to be thrown. Named nodes <it>can be put within the scope of an optionality operator</it>.
 *
 * <p> Named nodes that refer back to previous named nodes need not have a node
 * description -- this is known as "backreferencing".  In this case, the expression
 * will match only when all instances of the same name get matched to the same tree node.
 * For example: the pattern
 *
 * <blockquote>
 * <code> (@NP <, (@NP $+ (/,/ $+ (@NP $+ /,/=comma))) <- =comma) </code>
 * </blockquote>
 *
 * matches only an NP dominating exactly the four node sequence
 * <code>NP , NP ,</code> -- the mother NP cannot have any other
 * daughters. Multiple backreferences are allowed.  If the node w/ no
 * node description does not refer to a previously named node, there
 * will be no error, the expression simply will not match anything.
 *
 * <p> Another way to refer to previously named nodes is with the "link" symbol: '~'.
 * A link is like a backreference, except that instead of having to be <i>equal to</i> the
 * referred node, the current node only has to match the label of the referred to node.
 * A link cannot have a node description, i.e. the '~' symbol must immediately follow a
 * relation symbol.
 *
 * <p><h3>Customizing headship and basic categories</h3>
 *
 * <p> The HeadFinder used to determine heads for the head relations <code>&lt;#</code>, <code>&gt;#</code>, <code>&lt;&lt;#</code>, and <code>&gt;&gt;#</code>, and also
 * the Function mapping from labels to Basic Category tags can be
 * chosen by using a {@link TregexPatternCompiler}.
 *
 * <p><h3>Variable Groups</h3>
 *
 * <p> If you write a node description using a regular expression, you can assign its matching groups to variable names.
 * If more than one node has a group assigned to the same variable name, then matching will only occur when all such groups
 * capture the same string.  This is useful for enforcing coindexation constraints.  The syntax is
 *
 * <blockquote>
 * <code> / &lt;regex-stuff&gt; /#&lt;group-number&gt;%&lt;variable-name&gt;</code>
 * </blockquote>
 *
 * For example, the pattern (designed for Penn Treebank trees)
 *
 * <blockquote>
 * <code> @SBAR < /^WH.*-([0-9]+)$/#1%index << (__=empty < (/^-NONE-/ < /^\*T\*-([0-9]+)$/#1%index)) </code>
 * </blockquote>
 *
 * will match only such that the WH- node under the SBAR is coindexed with the trace node that gets the name <code>empty</code>.
 *
 * <p><h3>Getting Started</h3>
 *
 * Suppose we want to find all examples of subtrees where the label of
 * the root of the subtree starts with MW.  For example, we want any
 * subtree whose root is labeled MWV, MWN, etc.
 * <br>
 * The first thing to do is figure out what pattern to use.  Since we
 * want to match anything starting with MW, we use the pattern
 * <code>/^MW/</code>.
 * <br>
 * We then create a pattern, find matches in a given tree, and process
 * those matches as follows:
 * <blockquote>
 * <code>
 *   // Create a reusable pattern object <br>
 *   TregexPattern patternMW = TregexPattern.compile("/^MW/"); <br>
 *   // Run the pattern on one particular tree <br>
 *   TregexMatcher matcher = patternMW.matcher(tree); <br>
 *   // Iterate over all of the subtrees that matched <br>
 *   while (matcher.findNextMatchingNode()) { <br>
 *   &nbsp;&nbsp;Tree match = matcher.getMatch(); <br>
 *   &nbsp;&nbsp;// do what we want to with the subtree <br>
 *   }
 * </code>
 * </blockquote>
 *
 * <p><h3>Current known bugs/shortcomings:</h3>
 *
 * <ul>
 *
 * <li> Tregex does not support disjunctions at the root level.  For
 * example, the pattern <code>A | B</code> will not work.
 *
 * <li> Using multiple variable strings in one regex may not
 * necessarily work.  For example, suppose the first two regex
 * patterns are <code>/(.*)/#1%foo</code> and
 * <code>/(.*)/#1%bar</code>.  You might then want to write a pattern
 * that matches the concatenation of these patterns,
 * <code>/(.*)(.*)/#1%foo#2%bar</code>, but that will not work.
 *
 * </ul>
 *
 * @author Galen Andrew
 * @author Roger Levy (rog@csli.stanford.edu)
 * @author Anna Rafferty (filter mode)
 * @author John Bauer (extensively tested and bugfixed)
 */
