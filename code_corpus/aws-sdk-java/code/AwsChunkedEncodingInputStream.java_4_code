	public AwsChunkedEncodingInputStream(InputStream in, int maxBufferSize,
			byte[] kSigning, String datetime, String keyPath,
			String headerSignature, AWS4Signer aws4Signer) {
		if (in instanceof AwsChunkedEncodingInputStream) {
			// This could happen when the request is retried, and we need to re-calculate the signatures.
			AwsChunkedEncodingInputStream originalChunkedStream = (AwsChunkedEncodingInputStream)in;
			maxBufferSize = Math.max(originalChunkedStream.maxBufferSize, maxBufferSize);
			is = originalChunkedStream.is;
			decodedStreamBuffer = originalChunkedStream.decodedStreamBuffer;
		}
		else {
			is = in;
			decodedStreamBuffer = null;
		}

		if (maxBufferSize < DEFAULT_CHUNK_SIZE)
			throw new IllegalArgumentException("Max buffer size should not be less than chunk size");
		this.maxBufferSize = maxBufferSize;
		this.kSigning = kSigning;
		this.dateTime = datetime;
		this.keyPath = keyPath;
		this.headerSignature = headerSignature;
		this.priorChunkSignature = headerSignature;
		this.aws4Signer = aws4Signer;
	}
	
	@Override
	public int read() throws IOException {
		byte[] tmp = new byte[1];
        int count = read(tmp, 0, 1);
        if (count != -1) {
        	if (log.isDebugEnabled())
        		log.debug("One byte read from the stream.");
        	int unsignedByte = (int) tmp[0] & 0xFF;
            return unsignedByte;
        } else {
            return count;
        }
	}
	
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		if (b == null) {
			throw new NullPointerException();
		} else if (off < 0 || len < 0 || len > b.length - off) {
			throw new IndexOutOfBoundsException();
		} else if (len == 0) {
			return 0;
		}
		
		if (null == currentChunkIterator 
				|| !currentChunkIterator.hasNext()) {
			if (isTerminating)
				return -1;
			else {
				isTerminating = setUpNextChunk();
			}
		}
		
		int count = currentChunkIterator.read(b, off, len);
		if (count > 0) {
			isAtStart = false;
			if (log.isDebugEnabled())
	    		log.debug(count + " byte read from the stream.");
		}
		return count;
	}

	@Override
	public long skip(long n) throws IOException {
		if (n <= 0) {
			return 0;
		}
		long remaining = n;
		int toskip = (int) Math.min(DEFAULT_BUFFER_SIZE, n);
		byte[] temp = new byte[toskip];
		while (remaining > 0) {
			int count;
			if ( (count = read(temp, 0, toskip)) < 0) {
				break;
			}
			remaining -= count;
		}
		return n - remaining;
	}

