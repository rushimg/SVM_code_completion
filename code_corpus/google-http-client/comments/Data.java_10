  /**
   * Parses the given string value based on the given primitive type.
   * <p>
   * Types are parsed as follows:
   * </p>
   * <ul>
   * <li>{@link Void}: null</li>
   * <li>{@code null} or is assignable from {@link String} (like {@link Object}): no parsing</li>
   * <li>{@code char} or {@link Character}: {@link String#charAt(int) String.charAt}(0) (requires
   * length to be exactly 1)</li>
   * <li>{@code boolean} or {@link Boolean}: {@link Boolean#valueOf(String)}</li>
   * <li>{@code byte} or {@link Byte}: {@link Byte#valueOf(String)}</li>
   * <li>{@code short} or {@link Short}: {@link Short#valueOf(String)}</li>
   * <li>{@code int} or {@link Integer}: {@link Integer#valueOf(String)}</li>
   * <li>{@code long} or {@link Long}: {@link Long#valueOf(String)}</li>
   * <li>{@code float} or {@link Float}: {@link Float#valueOf(String)}</li>
   * <li>{@code double} or {@link Double}: {@link Double#valueOf(String)}</li>
   * <li>{@link BigInteger}: {@link BigInteger#BigInteger(String) BigInteger(String)}</li>
   * <li>{@link BigDecimal}: {@link BigDecimal#BigDecimal(String) BigDecimal(String)}</li>
   * <li>{@link DateTime}: {@link DateTime#parseRfc3339(String)}</li>
   * </ul>
   *
   * <p>
   * Note that this may not be the right behavior for some use cases.
   * </p>
   *
   * @param type primitive type or {@code null} to parse as a string
   * @param stringValue string value to parse or {@code null} for {@code null} result
   * @return parsed object or {@code null} for {@code null} input
   * @throws IllegalArgumentException if the given class is not a primitive class
   */
