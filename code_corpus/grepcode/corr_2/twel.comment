/**
     * Sorts the matrix slices into ascending order, according to the <i>natural
     * ordering</i> of the matrix values in the given <tt>[row,column]</tt>
     * position. The returned view is backed by this matrix, so changes in the
     * returned view are reflected in this matrix, and vice-versa. To sort
     * ranges use sub-ranging views. To sort by other dimensions, use dice
     * views. To sort descending, use flip views ...
     * <p>
     * The algorithm compares two 2-d slices at a time, determinining whether
     * one is smaller, equal or larger than the other. Comparison is based on
     * the cell <tt>[row,column]</tt> within a slice. Let <tt>A</tt> and
     * <tt>B</tt> be two 2-d slices. Then we have the following rules
     * <ul>
     * <li><tt>A &lt;  B  iff A.get(row,column) &lt;  B.get(row,column)</tt>
     * <li><tt>A == B iff A.get(row,column) == B.get(row,column)</tt>
     * <li><tt>A &gt;  B  iff A.get(row,column) &gt;  B.get(row,column)</tt>
     * </ul>
     * 
     * @param matrix
     *            the matrix to be sorted.
     * @param row
     *            the index of the row inducing the order.
     * @param column
     *            the index of the column inducing the order.
     * @return a new matrix view having slices sorted by the values of the slice
     *         view <tt>matrix.viewRow(row).viewColumn(column)</tt>. <b>Note
     *         that the original matrix is left unaffected.</b>
     * @throws IndexOutOfBoundsException
     *             if
     *             <tt>row < 0 || row >= matrix.rows() || column < 0 || column >= matrix.columns()</tt>
     *             .
     */
