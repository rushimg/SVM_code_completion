        @Override
        String getResponse() {
            final int ntRespLen = ntResp.length;
            final int lmRespLen = lmResp.length;

            final int domainLen = domainBytes != null ? domainBytes.length : 0;
            final int hostLen = hostBytes != null ? hostBytes.length: 0;
            final int userLen = userBytes.length;
            final int sessionKeyLen;
            if (sessionKey != null) {
                sessionKeyLen = sessionKey.length;
            } else {
                sessionKeyLen = 0;
            }

            // Calculate the layout within the packet
            final int lmRespOffset = 72;  // allocate space for the version
            final int ntRespOffset = lmRespOffset + lmRespLen;
            final int domainOffset = ntRespOffset + ntRespLen;
            final int userOffset = domainOffset + domainLen;
            final int hostOffset = userOffset + userLen;
            final int sessionKeyOffset = hostOffset + hostLen;
            final int finalLength = sessionKeyOffset + sessionKeyLen;

            // Start the response. Length includes signature and type
            prepareResponse(finalLength, 3);

            // LM Resp Length (twice)
            addUShort(lmRespLen);
            addUShort(lmRespLen);

            // LM Resp Offset
            addULong(lmRespOffset);

            // NT Resp Length (twice)
            addUShort(ntRespLen);
            addUShort(ntRespLen);

            // NT Resp Offset
            addULong(ntRespOffset);

            // Domain length (twice)
            addUShort(domainLen);
            addUShort(domainLen);

            // Domain offset.
            addULong(domainOffset);

            // User Length (twice)
            addUShort(userLen);
            addUShort(userLen);

            // User offset
            addULong(userOffset);

            // Host length (twice)
            addUShort(hostLen);
            addUShort(hostLen);

            // Host offset
            addULong(hostOffset);

            // Session key length (twice)
            addUShort(sessionKeyLen);
            addUShort(sessionKeyLen);

            // Session key offset
            addULong(sessionKeyOffset);

            // Flags.
            addULong(
                    //FLAG_WORKSTATION_PRESENT |
                    //FLAG_DOMAIN_PRESENT |

                    // Required flags
                    (type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) |
                    (type2Flags & FLAG_REQUEST_NTLMv1) |
                    (type2Flags & FLAG_REQUEST_NTLM2_SESSION) |

                    // Protocol version request
                    FLAG_REQUEST_VERSION |

                    // Recommended privacy settings
                    (type2Flags & FLAG_REQUEST_ALWAYS_SIGN) |
                    (type2Flags & FLAG_REQUEST_SEAL) |
                    (type2Flags & FLAG_REQUEST_SIGN) |

                    // These must be set according to documentation, based on use of SEAL above
                    (type2Flags & FLAG_REQUEST_128BIT_KEY_EXCH) |
                    (type2Flags & FLAG_REQUEST_56BIT_ENCRYPTION) |
                    (type2Flags & FLAG_REQUEST_EXPLICIT_KEY_EXCH) |

                    (type2Flags & FLAG_TARGETINFO_PRESENT) |
                    (type2Flags & FLAG_REQUEST_UNICODE_ENCODING) |
                    (type2Flags & FLAG_REQUEST_TARGET)
            );

            // Version
            addUShort(0x0105);
            // Build
            addULong(2600);
            // NTLM revision
            addUShort(0x0f00);

            // Add the actual data
            addBytes(lmResp);
            addBytes(ntResp);
            addBytes(domainBytes);
            addBytes(userBytes);
            addBytes(hostBytes);
            if (sessionKey != null) {
                addBytes(sessionKey);
            }

            return super.getResponse();
        }
    }

    static void writeULong(final byte[] buffer, final int value, final int offset) {
        buffer[offset] = (byte) (value & 0xff);
        buffer[offset + 1] = (byte) (value >> 8 & 0xff);
        buffer[offset + 2] = (byte) (value >> 16 & 0xff);
        buffer[offset + 3] = (byte) (value >> 24 & 0xff);
    }

    static int F(final int x, final int y, final int z) {
        return ((x & y) | (~x & z));
    }

    static int G(final int x, final int y, final int z) {
        return ((x & y) | (x & z) | (y & z));
    }

    static int H(final int x, final int y, final int z) {
        return (x ^ y ^ z);
    }

    static int rotintlft(final int val, final int numbits) {
        return ((val << numbits) | (val >>> (32 - numbits)));
    }

