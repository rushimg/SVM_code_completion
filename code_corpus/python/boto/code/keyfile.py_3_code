  def seek(self, pos, whence=os.SEEK_SET):
    self.key.close(fast=True)
    if whence == os.SEEK_END:
      # We need special handling for this case because sending an HTTP range GET
      # with EOF for the range start would cause an invalid range error. Instead
      # we position to one before EOF (plus pos) and then read one byte to
      # position at EOF.
      if self.key.size == 0:
        # Don't try to seek with an empty key.
        return
      pos = self.key.size + pos - 1
      if pos < 0:
        raise IOError("Invalid argument")
      self.key.open_read(headers={"Range": "bytes=%d-" % pos})
      self.key.read(1)
      self.location = pos + 1
      return
    if whence == os.SEEK_SET:
      if pos < 0:
        raise IOError("Invalid argument")
    elif whence == os.SEEK_CUR:
      pos += self.location
    else:
      raise IOError('Invalid whence param (%d) passed to seek' % whence)
    try:
      self.key.open_read(headers={"Range": "bytes=%d-" % pos})
    except StorageResponseError, e:
      # 416 Invalid Range means that the given starting byte was past the end
      # of file. We catch this because the Python file interface allows silently
      # seeking past the end of the file.
      if e.status != 416:
        raise
    self.location = pos
